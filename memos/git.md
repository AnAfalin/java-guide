# Git

+ `git config --global user.name "<name>"`
+ `git config --global user.email <email>`
+ `git config --global alias. <alias-name> <git-command>`
+ `git config --global --edit`
+ `git config --system core.editor <editor>`

+ `git init <directory>` - создание нового репозитория
+ `git clone <url> <path>` — клонирование удаленного репозитория

+ `git status` — просмотр текущих изменений
+ `git log` — просмотр истории изменений.
+ `git diff` — просмотр изменений между коммитами, коммитом и рабочим деревом

+ `git commit` — зафиксировать коммит в локальном репозитории
+ `git commit -m "Description"` — описание коммита в локальном репозитории. Это очень важный момент, так как информация 
должна лаконично описывать внесённые изменения.
+ `git push <remote> <branch>` — отправка изменений в удаленный репозиторий.
+ `git pull <remote>` — получение изменений из удалённого репозитория.
+ `git fetch <remote> <url>`

## git reset

`git reset [<mode>] [<commit>]`  
Сброс текущего состояния до `<commit>` и, возможно, обновляет индекс (сбрасывая его до коммита `<commit>`
дерева) и рабочее дерево в зависимости от `<mode>`. Перед операцией ORIG_HEAD устанвливается на конец коммитов текущей
ветки. Если `<mode>` опущен, то по умолчанию используется `--mixed`.

`<mode>` должен быть одним из следующих:

`--soft`  
Индексный файл или рабочее дерево не затрагиваются (но заголовок сбрасывается в `<commit>`, как и во всех режимах). Это
оставляет все ваши измененные файлы в "Changes to be committed" как показывает команда `git status`.

`--mixed`  
Сбрасывает индекс, но не рабочее дерево (т.е. измененные файлы сохраняются, но не помечаются для фиксации) и сообщает,
что не было обнволено. Это действие по умолчанию.

`--hard`  
Сбрасывает индекс и рабочее дерево. Любые изменения в отслеживаемых файлах в рабочем дереве после `<commit>`
отбрасываются. Любые неотслеживаемые файлы или каталоги на пути записи любых отслеживаемых файлоы просто удаляются.

`--merge`    
Сбрасывает индекс и обновляет файлы в рабочем дереве, которые различаются между <commit> и HEAD, но сохраняет те, которые
различаются между индексом и рабочим деревом (т. е. имеют изменения, которые не были добавлены).  Если файл, который
отличается между <commit> и индексом, имеет неиндексированные изменения, сброс прерывается.

Другими словами, --merge делает что-то вроде git read-tree -u -m <commit>, но переносит неслитые записи индекса вперед.

`--keep`  
Сбрасывает записи индекса и обновляет файлы в рабочем дереве, которые различаются между `<commit>` и HEAD. Если файл,
который различается между `<commit>` и HEAD и имеет локальные изменения, то сброс прерывается.

## Работа с ветками
+ `git branch` — просмотр списка веток. Текущая ветка будет отмечена (*).
+ `git branch <name>` — создать новую ветку с именем name.
+ `git checkout <name>` — переключиться на ветку name.
+ `git checkout -b <branch-name>` — создание новой ветки с указанным именем и переключение на неё.
+ `git push <remote> <name>` — отправить на сервер ветку
+ `git branch -d <name>` — удалить ветку с именем name в локальном репозитории.
+ `git push <remote> --delete <name>` — удалить ветку с именем name в удаленном репозитории.
+ `git merge <name>` — слияние текущей ветки с веткой name.

## Работа с файлами
+ git clean -f -d — удаление ненужных, неотслеживаемых файлов и прочего мусора

## Редактирование последнего коммита
```bash
git commit --amend 
# открывает редактор для смены сообщения
````

## Отменить изменения в файле
```bash
# найти хеш коммита, до которого нужно откатиться  
git log
# используйте стрелочки, чтобы прокрутить историю  
# сохраните хеш нужного коммита  
git checkout [сохранённый хеш] -- путь/к/файлу
# старая версия файла окажется в вашем индексе  
git commit -m "Ого, теперь не придётся копипастить, чтобы отменить изменения!"
```

## Отменить коммит, который был 5 коммитов назад
```bash
# найдите коммит, который нужно отменить
git log
# используйте стрелочки, чтобы прокрутить историю  
# сохраните хеш нужного коммита  
git revert [сохранённый хеш]
# git создаст новый коммит, отменяющий выбранный  
# отредактируйте сообщений коммита или просто сохраните  
```

## Случайно закоммитили что-то в мастер, хотя это должно быть в новой ветке
```bash
# создаст новую ветку из текущего состояния мастера
git branch какое-то-имя-новой-ветки
# удалит последний коммит из мастера
git reset HEAD~ --hard
git checkout какое-то-имя-новой-ветки
# ваш коммит теперь живёт в этой ветке :)
```

## Случайно закоммитили не в ту ветку
```bash 
# отменяет последний коммит, но оставляет изменения доступными
git reset HEAD~ --soft
git stash
# переключиться на нужную ветку
git checkout имя-нужной-ветки
git stash pop
git add . # или добавьте отдельные файлы
git commit -m "ваше сообщение здесь"
# теперь ваши изменения на нужной ветке
```

## Закоммитили, а что-то забыли
```bash 
# сделайте своё изменение
git add . # или добавьте файлы по отдельности
git commit --amend --no-edit
# теперь ваш последний коммит содержит это изменение!
# ПРЕДУПРЕЖДЕНИЕ: никогда не меняйте опубликованные коммиты!
```

## Накосячили, где у git волшебная машина времени
```bash 
git reflog
# вы увидите список всего,
# что сделали в git, во всех ветках!
# у каждого элемента есть индекс HEAD@{индекс}
# найдите тот, перед которым всё сломалось
git reset HEAD@{index}
# волшебная машина времени
```

