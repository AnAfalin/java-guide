#### [Оглавление](../README.md)

# Hibernate
+ [Что такое ORM? Что такое JPA? Что такое Hibernate?](#что-такое-orm-что-такое-jpa-что-такое-hibernate)
+ [Что такое EntityManager? Какие функции он выполняет?](#что-такое-entitymanager-какие-функции-он-выполняет)
+ [Каким условиям должен удовлетворять класс, чтобы являться Entity?](#каким-условиям-должен-удовлетворять-класс-чтобы-являться-entity)
+ [Может ли абстрактный класс быть Entity?](#может-ли-абстрактный-класс-быть-entity)
+ [Может ли entity-класс наследоваться от не entity-классов (non-entity classes)?](#может-ли-entity-класс-наследоваться-от-не-entity-классов--non-entityclasses--)
+ [Может ли entity-класс наследоваться от других entity-классов?](#может-ли-entity-класс-наследоваться-от-других-entity-классов)
+ [Может ли НЕ entity-класс наследоваться от entity-класса?](#может-ли-не-entity-класс-наследоваться-от-entity-класса)
+ [Что такое встраиваемый (embeddable) класс? Какие требования JPA устанавливает к встраиваемым (embeddable) классам?](#что-такое-встраиваемый--embeddable--класс-какие-требования-jpa-устанавливает-к-встраиваемым--embeddable--классам)
+ [Что такое Mapped Superclass?](#что-такое-mapped-superclass)
+ [Какие три типа стратегий наследования мапинга (Inheritance Mapping Strategies) описаны в JPA?](#какие-три-типа-стратегий-наследования-мапинга--inheritance-mapping-strategies--описаны-в-jpa)
+ [Как мапятся Enum'ы?](#как-мапятся-enumы)
+ [Как мапятся даты (до Java 8 и после)?](#как-мапятся-даты--до-java-8-и-после--)
+ [Как «смапить» коллекцию примитивов?](#как-смапить-коллекцию-примитивов)
+ [Какие есть виды связей?](#какие-есть-виды-связей)
+ [Что такое владелец связи?](#что-такое-владелец-связи)
+ [Что такое каскады?](#что-такое-каскады)
+ [Разница между PERSIST и MERGE?](#разница-между-persist-и-merge)
+ [Какие два типа fetch-стратегии в JPA вы знаете?](#Какие два типа fetch-стратегии в JPA вы знаете?)
+ [Какие четыре статуса жизненного цикла Entity-объекта (Entity Instance’s Life Cycle) вы можете перечислить?](#какие-четыре-статуса-жизненного-цикла-entity-объекта--entity-instances-life-cycle--вы-можете-перечислить)
+ [Как влияет операция persist на Entity-объекты каждого из четырех статусов?](#как-влияет-операция-persist-на-entity-объекты-каждого-из-четырех-статусов)
+ [Как влияет операция remove на Entity-объекты каждого из четырех статусов?](#как-влияет-операция-remove-на-entity-объекты-каждого-из-четырех-статусов)
+ [Как влияет операция merge на Entity-объекты каждого из четырех статусов?](#как-влияет-операция-merge-на-entity-объекты-каждого-из-четырехстатусов)
+ [Как влияет операция refresh на Entity-объекты каждого из четырех статусов?](#как-влияет-операция-refresh-на-entity-объекты-каждого-из-четырех-статусов)
+ [Как влияет операция detach на Entity-объекты каждого из четырех статусов?](#как-влияет-операция-detach-на-entity-объекты-каждого-из-четырехстатусов)
+ [Для чего нужна аннотация Basic?](#для-чего-нужна-аннотация-basic)
+ [Для чего нужна аннотация Column?](#для-чего-нужна-аннотация-column)
+ [Для чего нужна аннотация Access?](#для-чего-нужна-аннотация-access)
+ [Для чего нужна аннотация @Cacheable?](#для-чего-нужна-аннотация-cacheable)
+ [Для чего нужны аннотации @Embedded и @Embeddable?](#для-чего-нужны-аннотации-embedded-и-embeddable)
+ [Как смапить составной ключ?](#как-смапить-составной-ключ)
+ [Для чего нужна аннотация ID? Какие @GeneratedValue вы знаете?](#для-чего-нужна-аннотация-id-какие-generatedvalue-вы-знаете)
+ [Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются?](#расскажите-про-аннотации-joincolumn-и-jointable-где-и-для-чего-они-используются)
+ [Для чего нужны аннотации @OrderBy и @OrderColumn, чем они отличаются?](#для-чего-нужны-аннотации-orderby-и-ordercolumn-чем-они-отличаются)
+ [Для чего нужна аннотация Transient?](#для-чего-нужна-аннотация-transient)
+ [Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)?](#какие-шесть-видов-блокировок--lock--описаны-в-спецификации-jpa--или-какие-есть-значения-у-enum-lockmodetype-в-jpa--)
+ [Какие два вида кэшей (cache) вы знаете в JPA и для чего они нужны?](#какие-два-вида-кэшей--cache--вы-знаете-в-jpa-и-для-чего-они-нужны)
+ [Как работать с кешем 2 уровня?](#как-работать-с-кешем-2-уровня)
+ [Что такое JPQL/HQL и чем он отличается от SQL?](#что-такое-jpqlhql-и-чем-он-отличается-от-sql)
+ [Что такое Criteria API и для чего он используется?](#что-такое-criteria-api-и-для-чего-он-используется)
+ [Расскажите про проблему N+1 Select и путях ее решения](#расскажите-про-проблему-n1-select-и-путях-ее-решения)
+ [Что такое EntityGraph? Как и для чего их использовать?](#что-такое-entitygraph-как-и-для-чего-их-использовать)
+ [Мемоизация](#мемоизация)
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Что такое ORM? Что такое JPA? Что такое Hibernate?

__ORM (Object Relational Mapping)__ – это концепция преобразования данных из объектно-ориентированного языка в реляционные БД и наоборот.

__JPA (Java Persistence API)__ – это стандартная для Java спецификация, описывающая принципы ORM. JPA не умеет работать с объектами, 
а только определяет правила, как должен действовать каждый провайдер (Hibernate, EclipseLink), реализующий стандарт JPA.

JPA определяет правила, по которым должны описываться метаданные отображения и как должны работать провайдеры. Каждый 
провайдер обязан реализовывать все из JPA, определяя стандартное получение, сохранение, управление объектами. Можно добавлять
свои классы и интерфейсы. 

__Гибкость__ – код написанный с использованием классов и интерфейсов JPA, позволяет гибко менять одного провайдера на другого, 
но если использовать классы, аннотации и интерфейсы из конкретного провайдера, то это работать не будет.

JDO входит в JPA, NoSQL.

__Hibernate__ – библиотека, являющаяся реализацией JPA-спецификации, в которой можно использовать не только стандартные 
API-интерфейсы JPA, но и реализовать свои классы и интерфейсы.

Важные интерфейсы Hibernate:
+ __Session__ – обеспечивает физическое соединение между приложением и БД. Основная функция – предлагать DML-операции для 
экземпляров сущностей.
+ __SessionFactory__ – это фабрика для объектов Session. Обычно создается во время запуска приложения и сохраняется для 
последующего использования. Является потокобезопасным объектом и используется всеми потоками приложения.
+ __Transaction__ – однопоточный короткоживущий объект, используемый для атомарных операций. Это абстракция приложения 
от основных JDBC-транзакций. Session может занимать несколько Transaction в определенных случаях, является необязательным API.
+ __Query__ – интерфейс позволяет выполнять запросы к БД. Запросы написаны на HQL или на SQL.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Что такое EntityManager? Какие функции он выполняет?
__EntityManager__ – интерфейс JPA, который описывает API для всех основных операций над Entity, а также для получения 
данных и других сущностей JPA.

Основные операции:
1. Операции над Entity: persist (добавление Entity), merge (обновление), remove (удаление), refresh (обновление данных), 
detach (удаление из управление JPA), lock (блокирование Entity от изменений в других thread).
2. Получение данных: find (поиск и получение Entity), createQuery, createNamedQuery, createNativeQuery, contains, 
createNamedStoredProcedureQuery, createStoredProcedureQuery.
3. Получение других сущностей JPA: getTransaction, getEntityManagerFactory, getCriteriaBuilder, getMetamodel, getDelegate.
4. Работа с EntityGraph: createEntityGraph, getEntityGraph.
5. Общие операции над EntityManager или всеми Entities: close, clear, isOpen, getProperties, setProperty.
   
Объекты EntityManager не являются потокобезопасными. Это означает, что каждый поток должен получить свой экземпляр 
EntityManager, поработать с ним и закрыть его в конце.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Каким условиям должен удовлетворять класс, чтобы являться Entity?

__Entity__ – это легковесный хранимый объект бизнес логики. Основная программная сущность – это entity-класс, который 
может использовать дополнительные классы, которые могут использоваться как вспомогательные классы или для сохранения 
состояния еntity.

Требования к e ntity-классу:
+ должен быть помечен аннотацией Entity или описан в XML-файле;
+ должен содержать public или protected конструктор без аргументов (он также может иметь конструкторы с аргументами) – 
при получении данных из БД и формировании из них объекта сущности Hibernate должен создать этот объект сущности$
+ должен быть классом верхнего уровня (top-level class);
+ не может быть enum или интерфейсом;
+ не может быть финальным классом (final class);
+ не может содержать финальные поля или методы, если они участвуют в маппинге 
(persistent final methods or persistent final instance variables);
+ если объект entity-класса будет передаваться по значению как отдельный объект (detached object), например, через 
удаленный интерфейс (through a remote interface), он должен реализовывать интерфейс Serializable;
+ поля entity-класса должны быть напрямую доступны только методам самого entityкласса и не должны быть напрямую 
доступны другим классам, использующим этот entity. Такие классы должны обращаться только к методам (getter/setter методам 
или другим методам бизнес-логики в entity-классе);
+ должен содержать первичный ключ, то есть атрибут или группу атрибутов, которые уникально определяют запись этого 
entity-класса в базе данных.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Может ли абстрактный класс быть Entity?

Может, при этом он сохраняет все свойства Entity, за исключением того, что его нельзя непосредственно инициализировать.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Может ли entity-класс наследоваться от не entity-классов (non-entityclasses)?

Может.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Может ли entity-класс наследоваться от других entity-классов?

Может.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Может ли НЕ entity-класс наследоваться от entity-класса?

Может.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Что такое встраиваемый (embeddable) класс? Какие требования JPA устанавливает к встраиваемым (embeddable) классам?

__Embeddable-класс__ – это класс, который не используется сам по себе, а является частью одного или нескольких entity-классов. 

Entity-класс может содержать как одиночные встраиваемые классы, так и коллекции таких классов. Также такие классы могут 
быть использованы как ключи или значения map. Во время выполнения каждый встраиваемый класс принадлежит только одному 
объекту entity-класса и не может быть использован для передачи данных между объектами entity-классов (то есть такой класс 
не является общей структурой данных для разных объектов). В целом, такой класс служит для того, чтобы выносить определение 
общих атрибутов для нескольких entity.
   
Такие классы должны удовлетворять тем же правилам, что entity-классы, за исключением того, что они не обязаны содержать 
первичный ключ и быть отмечены аннотацией Entity. 

Embeddable-класс должен быть помечен аннотацией @Embeddable или описан в XML-файле конфигурации JPA. А поле этого класса 
в Entity аннотацией @Embedded.

Embeddable-класс может содержать другой встраиваемый класс. 
Встраиваемый класс может содержать связи с другими Entity или коллекциями Entity, если такой класс не используется как 
первичный ключ или ключ map'ы.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Что такое Mapped Superclass?

__Mapped Superclass__ – это класс, от которого наследуются Entity, он может содержать анотации JPA, однако сам такой 
класс не является Entity, ему необязательно выполнять все требования, установленные для Entity (например, он может не 
содержать первичного ключа).
   
Такой класс не может использоваться в операциях EntityManager или Query. Такой класс должен быть отмечен аннотацией 
MappedSuperclass или описан в xml-файле. 

Создание такого класса-предка оправдано тем, что заранее определяется ряд свойств и методов в сущностях. Использование 
такого подхода позволило сократить количество кода.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Какие три типа стратегий наследования мапинга (Inheritance Mapping Strategies) описаны в JPA?
`Inheritance Mapping Strategies` описывает как JPA будет работать с классами-наследниками Entity:

1. __Одна таблица на всю иерархию классов (SINGLE_TABLE)__ – все entity со всеми наследниками записываются в одну таблицу, 
для идентификации типа entity определяется специальная колонка «discriminator column». 

Например, есть entity Animals c классами-потомками Cats и Dogs. При такой стратегии все entity записываются в таблицу 
Animals, но при этом имеют дополнительную колонку animalType, в которую соответственно пишется значение «cat» или «dog». 
Минусом является то, что в общей таблице будут созданы все поля, уникальные для каждого из классов-потомков, которые будут 
пусты для всех других классов-потомков. Например, в таблице animals окажется и скорость лазанья по дереву от cats, и может 
ли пес приносить тапки от dogs, которые будут всегда иметь null для dog и cat соответственно.

Нельзя делать constraints notNull, но можно использовать триггеры.

2. __Стратегия «соединения» (JOINED_TABLE)__ – в этой стратегии каждый класс entity сохраняет данные в свою таблицу, 
но только уникальные поля (не унаследованные от классов-предков) и первичный ключ, а все унаследованные колонки записываются 
в таблицы класса-предка, дополнительно устанавливается связь (relationships) между этими таблицами, например, в случае 
классов Animals будут три таблицы: animals, cats, dogs.

Причем в cats будет записан только ключ и скорость лазанья, в dogs – ключ и умеет ли пес приносить палку, а в animals все 
остальные данные cats и dogs c ссылкой на соответствующие таблицы. Минусом является потеря производительности от объединения 
таблиц (join) для любых операций.

3. __Таблица для каждого класса (TABLE_PER_CLASS)__ – каждый отдельный класс-наследник имеет свою таблицу, т. е. 
для cats и dogs все данные будут записываться просто в таблицы cats и dogs как если бы они вообще не имели общего суперкласса. 
Минусом является плохая поддержка полиморфизма (polymorphic relationships) и то, что для выборки всех классов иерархии 
потребуются большое количество отдельных sql-запросов или использование UNION-запроса.

Для задания стратегии наследования используется аннотация Inheritance (или соответствующие блоки).
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Как мапятся Enum'ы?
+ `@Enumerated(EnumType.STRING)` означает, что в базе будут храниться имена Enum.
+ `@Enumerated(EnumType.ORDINAL)` – в базе будут храниться порядковые номера Enum.

Другой вариант – можно смапить enum в БД и обратно в методах с аннотациями `@PostLoad` и `@PrePersist`. 
`@EntityListener` над классом Entity, где указать класс, в котором создать два метода, помеченных этими аннотациями.

Идея в том, чтобы в сущности иметь не только поле с `Enum`, но и вспомогательное поле.

Поле с Enum аннотируем `@Transient`, а в БД будет храниться значение из вспомогательного поля.

В JPA с версии 2.1 можно использовать Converter для конвертации Enum’а в некое его значение для сохранения в БД и 
получения из БД. Нужно лишь создать новый класс, который реализует `javax.persistence.AttributeConverter` и аннотировать его с помощью
`@Converter` и поле в сущности аннотацией `@Convert`.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Как мапятся даты (до Java 8 и после)?
   
Аннотация `@Temporal` до Java 8, в которой надо было указать, какой тип даты хотим использовать.
   
В Java 8 и далее аннотацию ставить не нужно.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Как «смапить» коллекцию примитивов?
`@ElementCollection`

`@OrderBy`

Если у сущности есть поле с коллекцией, то обычно ставят над ним аннотации @OneToMany либо @ManyToMany. Но данные 
аннотации применяются, когда это коллекция других сущностей (entities). Если у сущности коллекция не других сущностей, 
а базовых или встраиваемых (embeddable) типов, то для этих случаев в JPA имеется специальная аннотация `@ElementCollection`, 
которая указывается в классе сущности над полем коллекции. 

Все записи коллекции хранятся в отдельной таблице, то есть в итоге получаем две таблицы: одну для сущности, вторую для коллекции элементов.
   
При добавлении новой строки в коллекцию она полностью очищается и заполняется заново, так как у элементов нет id. Можно 
решить с помощью `@OrderColumn`. 
`@CollectionTable` позволяет редактировать таблицу с коллекцией.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Какие есть виды связей?
   Существуют 4 типа связей:
1. `OneToOne` – когда один экземпляр Entity может быть связан не больше чем с одним
   экземпляром другого Entity.
   Необходимо ставить forieghnKey на родительскую таблицу и аннотацию JoinColomun, в
   атрибуте name объяснить, к какой колонке ссылаться на родительской сущности.
   Что стоит в поле, где все связано? Стоит тип другой сущности.
2. `OneToMany` – когда один экземпляр Entity может быть связан с несколькими
   экземплярами других Entity. Когда одна сущность может ссылаться ко многим сущностям.
   Храним коллекцию.
3. `ManyToOne` – обратная связь для OneToMany. Несколько экземпляров Entity могут быть
   связаны с одним экземпляром другого Entity. Несколько машин может быть у нескольких
   юзеров.
   Одна сущность хранится.
4. `ManyToMany` – экземпляры Entity могут быть связаны с несколькими экземплярами друг
   друга. Каждый из двух Entity может быть по несколько других Entity. Много сущностей могут
   относиться к многим сущностями.
   Сводная таблица с айдишниками, коллекции коллекций хранятся.

Каждую из которых можно разделить ещё на два вида:
1. `Bidirectional` с использованием @MappedBy на стороне, где указывается `@OneToMany`
2. `Unidirectional.`

__Bidirectional__ – ссылка на связь устанавливается у всех Entity, то есть в случае OneToOne A-B в Entity A есть ссылка 
на Entity B, в Entity B есть ссылка на Entity A. Entity A считается владельцем этой связи (это важно для случаев каскадного 
удаления данных, тогда при удалении A также будет удалено B, но не наоборот).

__Undirectional__ – ссылка на связь устанавливается только с одной стороны, то есть в случае OneToOne A-B только у 
Entity A будет ссылка на Entity B, у Entity B ссылки на A не будет.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Что такое владелец связи?

В отношениях между двумя сущностями всегда есть одна владеющая сторона, а зависимой может и не быть, если это 
однонаправленные отношения.
   
По сути, у кого есть внешний ключ на другую сущность, тот и владелец связи. То есть, если в таблице одной сущности есть 
колонка, содержащая внешние ключи от другой сущности, то первая сущность признается владельцем связи, вторая сущность – зависимой.
   
В однонаправленных отношениях сторона, которая имеет поле с типом другой сущности, является владельцем этой связи по умолчанию.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Что такое каскады?
__Каскадирование__ – это какое-то действие с целевой Entity, то же самое действие будет применено к связанной Entity.
   
JPA CascadeType:
+ ALL гарантирует, что все персистентные события, которые происходят на родительском объекте, будут переданы дочернему объекту;
+ PERSIST означает, что операции save() или persist() каскадно передаются связанным объектам;
+ MERGE означает, что связанные entity объединяются, когда объединяется entity-владелец;
+ REMOVE удаляет все entity, связанные с удаляемой entity;
+ DETACH отключает все связанные entity, если происходит «ручное отключение»;
+ REFRESH повторно считывает значение данного экземпляра и связанных сущностей из базы данных при вызове refresh().
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Разница между PERSIST и MERGE?

`persist(entity)` следует использовать с новыми объектами, чтобы добавить их в БД (если объект уже существует в БД, 
будет выброшено исключение EntityExistsException).
   
Если использовать merge(entity), то сущность, которая уже управляется в контексте персистентности, будет заменена 
новой сущностью (обновленной), и копия этой обновленной сущности вернется обратно. Рекомендуется использовать для уже
сохраненных сущностей.
   ___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Какие два типа fetch-стратегии в JPA вы знаете?

1. `LAZY` – Hibernate может загружать данные не сразу, а при первом обращении к ним, но так как это необязательное 
требование, то Hibernate имеет право изменить это поведение и загружать их сразу. Это поведение по умолчанию для полей, 
аннотированных @OneToMany, `@ManyToMany` и `@ElementCollection`. В объект загружается прокси lazy-поля. Если там стоит
коллекция, то это будет коллекция Hibernate, именуемая типом коллекции bag().

Подгрузка должна происходить в одной транзакции или пока не закроем ЕнтитуМенеджер. 

Если обратимся за персистетнымКонтекстом, то LazyEnitialization. 

Если используем Бэк, то он использует Лист и Сет и т. д.

2. `EAGER` – данные поля будут загружены немедленно. Это поведение по умолчанию для полей, аннотированных `@Basic`, `@ManyToOne` и `@OneToOne`.

Все, что заканчивается на One – Eager, Many – Lazy. Для кого можем использовать ManyToOne? Для владельца связи.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Какие четыре статуса жизненного цикла Entity-объекта (Entity Instance’s Life Cycle) вы можете перечислить?

+ transient (new) – свежесозданная оператором new() сущность не имеет связи с базой данных, не имеет данных в базе 
данных и не имеет сгенерированных первичных ключей и не имеет контекста Персистентности. При сохранении переходит в managed.
+ managed – объект уже создан и получает первичный ключ, управляется контекстом персистентности. 
(сохранен в БД, имеет primary key), переходит под управляется JPA, если вызываем detached, то полностью отвязываем от контекста.
+ detached – не управляется JPA, но может существовать в БД, объект создан, но не управляется JPA. В этом состоянии 
сущность не связана со своим контекстом (отделена от него) и нет экземпляра Session, который бы ей управлял.
+ removed – объект создан, управляется JPA, будет удален из БД, при commit-е транзакции статус станет опять detached.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Как влияет операция persist на Entity-объекты каждого из четырех статусов?

+ new → managed, объект будет сохранен в базу при commit-е транзакции или в результате flush-операций;
+ managed → операция игнорируется, однако зависимые Entity могут поменять статус на managed, если у них есть аннотации каскадных изменений;
+ detached → exception сразу или на этапе commit-а транзакции;
+ removed → managed, но только в рамках одной транзакции.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Как влияет операция remove на Entity-объекты каждого из четырех статусов?

+ new → операция игнорируется, однако зависимые Entity могут поменять статус на removed, если у них есть аннотации каскадных изменений и они имели статус managed;
+ managed → removed, запись объекта в базе данных будет удалена при commit-е транзакции (также произойдут операции remove для всех каскаднозависимых объектов);
+ detached → exception сразу или на этапе commit-а транзакции;
+ removed → операция игнорируется.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Как влияет операция merge на Entity-объекты каждого из четырехстатусов?

+ new → будет создан новый managed entity, в который будут скопированы данные прошлого объекта;
+ managed → операция игнорируется, однако операция merge сработает на каскаднозависимые Entity, если их статус не managed;
+ detached → либо данные будут скопированы в существующий managed entity с тем же первичным ключом, либо создан новый managed, в который скопируются данные;
+ removed → exception сразу или на этапе commit-а транзакции.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Как влияет операция refresh на Entity-объекты каждого из четырех статусов?

+ managed → будут восстановлены все изменения из базы данных данного Entity, также произойдет refresh всех каскаднозависимых объектов;
+ new, removed, detached → exception.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Как влияет операция detach на Entity-объекты каждого из четырехстатусов?

+ managed, removed → detached;
+ new, detached → операция игнорируется.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Для чего нужна аннотация Basic?

`@Basic` указывает на простейший тип маппинга данных на колонку таблицы базы данных. В параметрах аннотации можно указать 
fetch стратегию доступа к полю и является ли это поле обязательным или нет. Может быть применена к полю любого из следующих типов

+ примитивы и их обертки;
+ java.lang.String;
+ java.math.BigInteger;
+ java.math.BigDecimal;
+ java.util.Date;
+ java.util.Calendar;
+ java.sql.Date;
+ java.sql.Time;
+ java.sql.Timestamp;
+ byte[] or Byte[];
+ char[] or Character[];
+ enums;
+ любые другие типы, которые реализуют Serializable.

Аннотацию `@Basic` можно не ставить, как это и происходит по умолчанию.

Аннотация `@Basic` определяет 2 атрибута:
1. optional – boolean (по умолчанию true) – определяет, может ли значение поля или
   свойства быть null. Игнорируется для примитивных типов. Но если тип поля не примитивного
   типа, то при попытке сохранения сущности будет выброшено исключение.
2. fetch – FetchType (по умолчанию EAGER) – определяет, должен ли этот атрибут
   извлекаться незамедлительно (EAGER) или лениво (LAZY). Это необязательное требование
   JPA, и провайдерам разрешено незамедлительно загружать данные, даже для которых
   установлена ленивая загрузка.
   Без аннотации @Basic при получении сущности из БД по умолчанию ее поля базового типа
   загружаются принудительно (EAGER) и значения этих полей могут быть null.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Для чего нужна аннотация Column?
`@Column` сопоставляет поле класса столбцу таблицы, а ее атрибуты определяют поведение в этом столбце, используется для генерации схемы базы данных.
   
`@Basic` vs `@Column`:
1. Атрибуты `@Basic` применяются к сущностям JPA, тогда как атрибуты @Column применяются к столбцам базы данных.
2. `@Basic` имеет атрибут optional, который говорит о том, может ли поле объекта быть null или нет; с другой стороны 
атрибут nullable аннотации @Column указывает, может ли соответствующий столбец в таблице быть null.
3. Можно использовать `@Basic`, чтобы указать, что поле должно быть загружено лениво.
4. Аннотация `@Column` позволяет указать имя столбца в таблице и ряд других свойств:
+ `insertable/updatable` – можно ли добавлять/изменять данные в колонке, по умолчанию true;
+ `length` – длина, для строковых типов данных, по умолчанию 255. Коротко, в `@Column` задаем `constraints`, а в `@Basic` – `FetchTypes`.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Для чего нужна аннотация Access?

Определяет тип доступа к полям сущности. Для чтения и записи этих полей есть два подхода:

1. Field access (доступ по полям). При таком способе аннотации маппинга (Id, Column,...)
размещаются над полями, и Hibernate напрямую работает с полями сущности, читая и записывая их.

2. Property access (доступ по свойствам). При таком способе аннотации размещаются над методами-геттерами, но не над сеттерами.

По умолчанию тип доступа определяется местом, в котором находится аннотация `@Id`. Если она будет над полем – это будет 
`AccessType.FIELD`, если над геттером – это`AccessType.PROPERTY`.
   
Чтобы явно определить тип доступа у сущности, нужно использовать аннотацию `@Access`, которая может быть указана у сущности, 
`Mapped Superclass` и `Embeddable class`, а также над полями или методами.

Поля, унаследованные от суперкласса, имеют тип доступа этого суперкласса. Если у одной сущности определены разные типы доступа, 
то нужно использовать аннотацию `@Transient` для избежания дублирования маппинга.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Для чего нужна аннотация @Cacheable?
`@Cacheable` – необязательная аннотация JPA, используется для указания того, должна ли сущность храниться в кеше второго уровня.

В JPA говорится о пяти значениях shared-cache-mode из persistence.xml, который определяет как будет использоваться second-level cache:

+ `ENABLE_SELECTIVE`: только сущности с аннотацией @Cacheable (равносильно значению по умолчанию @Cacheable(value = true)) 
будут сохраняться в кеше второго уровня;
+ `DISABLE_SELECTIVE`: все сущности будут сохраняться в кеше второго уровня, за исключением сущностей, помеченных 
`@Cacheable(value = false)` как некешируемые;
+ `ALL`: сущности всегда кешируются, даже если они помечены как некешируемые;
+ `NONE`: ни одна сущность не кешируется, даже если помечена как кешируемая. При данной опции имеет смысл вообще отключить кеш второго уровня;
+ `UNSPECIFIED`: применяются значения по умолчанию для кеша второго уровня, определенные Hibernate. Это эквивалентно тому, 
что вообще не используется shared-cache-mode, так как Hibernate не включает кеш второго уровня, если используется режим UNSPECIFIED.
+ 
Аннотация `@Cacheable` размещается над классом сущности. Ее действие распространяется на эту сущность и ее наследников, 
если они не определили другое поведение.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Для чего нужны аннотации @Embedded и @Embeddable?

`@Embeddable` – аннотация JPA, размещается над классом для указания того, что класс является встраиваемым в другие классы.

`@Embedded` – аннотация JPA, используется для размещения над полем в классе-сущности для указания того, что внедряется встраиваемый класс.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Как смапить составной ключ?

__Составной первичный ключ__, также называемый составным ключом, представляет собой комбинацию из двух или более 
столбцов для формирования первичного ключа таблицы.

`@IdClass`

Допустим, есть таблица с именем Account, и она имеет два столбца – `accountNumber` и `accountType`, которые формируют 
составной ключ. Чтобы обозначить оба этих поля как части составного ключа, необходимо создать класс, например, 
ComplexKey с этими полями. 

Затем нужно аннотировать сущность Account аннотацией `@IdClass(ComplexKey.class)` и объявить поля из класса ComplexKey в 
сущности Account с такими же именами и аннотировать их с помощью @Id.

`@EmbeddedId`

Допустим, что необходимо сохранить некоторую информацию о книге с заголовком и языком в качестве полей первичного 
ключа. В этом случае класс первичного ключа, `BookId`, должен быть аннотирован `@Embeddable`.

Затем нужно встроить этот класс в сущность Book, используя `@EmbeddedId`.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Для чего нужна аннотация ID? Какие @GeneratedValue вы знаете?

Аннотация @Id определяет простой (не составной) первичный ключ, состоящий из одного поля. В соответствии с JPA, 
допустимые типы атрибутов для первичного ключа:

+ примитивные типы и их обертки; 
+ строки; 
+ BigDecimal и BigInteger; 
+ java.util.Date и java.sql.Date.

Если хотим, чтобы значение первичного ключа генерировалось автоматически, необходимо добавить первичному ключу, 
отмеченному аннотацией @Id, аннотацию @GeneratedValue.

Возможны 4 варианта:
1. `AUTO (default)`. Указывает, что Hibernate должен выбрать подходящую стратегию для
   конкретной базы данных, учитывая ее диалект, так как у разных БД разные способы по
   умолчанию. Поведение по умолчанию – исходить из типа поля идентификатора.
2. `IDENTITY`. Для генерации значения первичного ключа будет использоваться столбец
   IDENTITY, имеющийся в базе данных. Значения в столбце автоматически увеличиваются вне
   текущей выполняемой транзакции (на стороне базы, так что этого столбца не увидим, что
   позволяет базе данных генерировать новое значение при каждой операции вставки). В
   промежутках транзакций сущность будет сохранена.
3. `SEQUENCE`. Тип генерации, рекомендуемый документацией Hibernate. Для получения
   значений первичного ключа Hibernate должен использовать имеющиеся в базе данных
   механизмы генерации последовательных значений (Sequence). В БД можно будет увидеть
   дополнительную таблицу. Но если БД не поддерживает тип SEQUENCE, то Hibernate
   автоматически переключится на тип TABLE. В промежутках транзакций сущность не будет
   сохранена, так как Hibernate возьмет из таблицы id hibernate-sequence и вернется обратно в
   приложение. `SEQUENCE` – это объект базы данных, который генерирует инкрементные
   целые числа при каждом последующем запросе.
4. `TABLE`. Hibernate должен получать первичные ключи для сущностей из создаваемой для
   этих целей таблицы, способной содержать именованные сегменты значений для любого
   количества сущностей. Требует использования пессимистических блокировок, которые
   помещают все транзакции в последовательный порядок и замедляет работу приложения.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются?

`@JoinColumn `используется для указания столбца FOREIGN KEY, используемого при установлении связей между сущностями или к
оллекциями. Только сущность-владелец связи может иметь внешние ключи от другой сущности (владеемой). Но можно 
указать @JoinColumn как во владеющей таблице, так и во владеемой, но столбец с внешними ключами все равно появится во владеющей таблице.

Особенности использования:
+ `@OneToOne`: означает, что появится столбец в таблице сущности-владельца связи, который будет содержать внешний ключ, 
ссылающийся на первичный ключ владеемой сущности;
+ `@OneToMany/@ManyToOne`: если не указать на владеемой стороне связи `@mappedBy`, создается `joinTable` с ключами обеих таблиц. 
Но при этом же у владельца создается столбец с внешними ключами. 
 
`@JoinColumns` используется для группировки нескольких аннотаций @JoinColumn, которые используются при установлении 
связей между сущностями или коллекциями, у которых составной первичный ключ и требуется несколько колонок для указания внешнего ключа.
   
В каждой аннотации `@JoinColumn` должны быть указаны элементы `name` и `referencedColumnName`.

`@JoinTable` используется для указания связывающей (сводной, третьей) таблицы между двумя другими таблицами.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Для чего нужны аннотации @OrderBy и @OrderColumn, чем они отличаются?

`@OrderBy` указывает порядок, в соответствии с которым должны располагаться элементы коллекций сущностей, базовых или 
встраиваемых типов при их извлечении из БД. Если в кеше есть нужные данные, то сортировки не будет, так как `@OrderBy` 
просто добавляет к sql-запросу Order By, а при получении данных из кеша, обращения к БД нет. Эта аннотация может использоваться
с аннотациями `@ElementCollection`, `@OneToMany`, `@ManyToMany`.

При использовании с коллекциями базовых типов, которые имеют аннотацию `@ElementCollection`, элементы этой коллекции будут 
отсортированы в натуральном порядке, по значению базовых типов.

Если это коллекция встраиваемых типов (`@Embeddable`), то, используя точку ("."), можно сослаться на атрибут внутри встроенного атрибута.

Если это коллекция сущностей, то у аннотации `@OrderBy` можно указать имя поля сущности, по которому сортировать эти сущности:
Если не указывать у `@OrderBy` параметр, то сущности будут упорядочены по первичному ключу.

В случае с сущностями доступ к полю по точке (".") не работает. Попытка использовать вложенное свойство, например, 
`@OrderBy ("supervisor.name")` повлечет Runtime `Exceprtion`.

`@OrderColumn` создает в таблице столбец с индексами порядка элементов, который используется для поддержания постоянного 
порядка в списке, но этот столбец не считается частью состояния сущности или встраиваемого класса.

Hibernate отвечает за поддержание порядка как в базе данных при помощи столбца, так и при получении сущностей и 
элементов из БД. Hibernate отвечает за обновление порядка при записи в базу данных, чтобы отразить любое добавление, 
удаление или иное изменение порядка, влияющее на список в таблице.

@OrderBy vs @OrderColumn
Порядок, указанный в @OrderBy, применяется только в рантайме при выполнении запроса к БД, То есть в контексте 
персистентности, в то время как при использовании @OrderColumn, порядок сохраняется в отдельном столбце таблицы и 
поддерживается при каждой вставке/обновлении/удалении элементов.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Для чего нужна аннотация Transient?

`@Transient` используется для объявления того, какие поля у сущности, встраиваемого класса или Mapped SuperClass не будут 
сохранены в базе данных.

__Persistent fields (постоянные поля)__ – это поля, значения которых будут по умолчанию сохранены в БД. Ими являются 
любые не static и не final поля.

Transient fields (временные поля):
+ static и final поля сущностей;
+ иные поля, объявленные явно с использованием Java-модификатора transient либо JPA-аннотации @Transient.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)?

В порядке от самого ненадежного и быстрого, до самого надежного и медленного:

1. `NONE` – без блокировки.

2. `OPTIMISTIC` (синоним READ в JPA 1) – оптимистическая блокировка: если при завершении транзакции кто-то извне изменит 
поле @Version, то будет сделан RollBack транзакции и будет выброшено OptimisticLockException.

3. `OPTIMISTIC_FORCE_INCREMENT` (синоним WRITE в JPA 1) – работает по тому же алгоритму, что и LockModeType.OPTIMISTIC 
за тем исключением, что после commit значение поля Version принудительно увеличивается на 1. В итоге после каждого коммита 
поле увеличится на 2 (увеличение, которое можно увидеть в Post-Update + принудительное увеличение).

4. `PESSIMISTIC_READ` – данные блокируются в момент чтения, и это гарантирует, что никто в ходе выполнения транзакции не 
сможет их изменить. Остальные транзакции смогут параллельно читать эти данные. Использование этой блокировки может 
вызывать долгое ожидание блокировки или даже выкидывание `PessimisticLockException`.

5. `PESSIMISTIC_WRITE` – данные блокируются в момент записи, и никто с момента захвата блокировки не может в них писать 
и не может их читать до окончания транзакции, владеющей блокировкой. Использование этой блокировки может вызывать долгое ожидание блокировки.

6. `PESSIMISTIC_FORCE_INCREMENT` – ведет себя как PESSIMISTIC_WRITE, но в конце транзакции увеличивает значение поля 
`@Version`, даже если фактически сущность не изменилась.

__Оптимистичное блокирование__ – подход предполагает, что параллельно выполняющиеся транзакции редко обращаются к одним и
тем же данным, позволяет им свободно выполнять любые чтения и обновления данных. Но при окончании транзакции производится 
проверка, изменились ли данные в ходе выполнения данной транзакции и, если да, транзакция обрывается и выбрасывается 
`OptimisticLockException`. 

Оптимистичное блокирование в JPA реализовано с помощью внедрения в сущность специального поля версии:
```java
@Version
private long version;
```
   
Поле, аннотирование `@Version`, может быть целочисленным или временнЫм. При завершении транзакции, если сущность 
была заблокирована оптимистично, будет проверено, не изменилось ли значение @Version кем-либо еще после того, как данные 
были прочитаны, и, если изменилось, будет выкинуто OptimisticLockException. Использование этого поля позволяет отказаться 
от блокировок на уровне базы данных и сделать все на уровне JPA, улучшая уровень конкурентности. Позволяет отказаться от 
блокировок на уровне БД и делать все с JPA.

__Пессимистичное блокирование__ – подход ориентирован на транзакции, которые часто конкурируют за одни и те же данные, 
поэтому блокируется доступ к данным в тот момент, когда происходит чтение. Другие транзакции останавливаются, когда пытаются 
обратиться к заблокированным данным, и ждут снятия блокировки (или кидают исключение).

__Пессимистичное блокирование__ выполняется на уровне базы и поэтому не требует вмешательств в код сущности.

Блокировки ставятся с помощью вызова метода `lock()` у `EntityManager`, в который передается сущность, требующая блокировки и уровень блокировки:
```java
EntityManager em = entityManagerFactory.createEntityManager();
em.lock(company1, LockModeType.OPTIMISTIC);
```
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Какие два вида кэшей (cache) вы знаете в JPA и для чего они нужны?

+ first-level cache (кеш первого уровня) кеширует данные одной транзакции;
+ second-level cache (кеш второго уровня) кэширует данные транзакций от одной фабрики сессий. Провайдер JPA может, но не 
обязан реализовывать работу с кешем второго уровня.

Кеш первого уровня – это кеш сессии (Session), который является обязательным, это и есть PersistenceContext. Через него проходят все запросы.

Если выполняем несколько обновлений объекта, Hibernate старается отсрочить (насколько это возможно) обновление этого объекта 
для того, чтобы сократить количество выполненных запросов в БД. Например, при пяти обращении к одному и тому же объекту из 
БД в рамках одного persistence context, запрос в БД будет выполнен один раз, а остальные четыре загрузки будут выполнены из кеша. 
Если закроем сессию, то все объекты, находящиеся в кеше, теряются, а далее – либо сохраняются в БД, либо обновляются.

Особенности кеша первого уровня:
+ включен по умолчанию, его нельзя отключить;
+ связан с сессией (контекстом персистентности), то есть разные сессии видят только объекты из своего кеша и не видят объекты, 
находящиеся в кешах других сессий;
+ при закрытии сессии PersistenceContext очищается – кешированные объекты, находившиеся в нем, удаляются;
+ при первом запросе сущности из БД она загружается в кеш, связанный с этой сессией;
+ если в рамках этой же сессии снова запросим эту же сущность из БД, то она будет загружена из кеша и повторного 
SQL-запроса в БД сделано не будет;
+ сущность можно удалить из кеша сессии методом evict(), после чего следующая попытка получить эту же сущность повлечет 
обращение к базе данных;
+ метод clear() очищает весь кеш сессии.

Если кеш первого уровня привязан к объекту сессии, то кеш второго уровня привязан к объекту-фабрике сессий (Session Factory object), 
поэтому кеш второго уровня доступен одновременно в нескольких сессиях или контекстах персистентности. Кеш второго уровня 
требует некоторой настройки и поэтому не включен по умолчанию. Настройка кеша заключается в конфигурировании реализации 
кеша и разрешения сущностям быть закешированными.

Hibernate не реализует сам никакого in-memory сache, а использует существующие реализации кешей.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Как работать с кешем 2 уровня?

Чтение из кеша второго уровня происходит только в том случае, если нужный объект не был найден в кеше первого уровня.
   
Hibernate поставляется со встроенной поддержкой стандарта кеширования Java JCache, а также двух популярных библиотек кеширования: `Ehcache` и `Infinispan`.

В Hibernate кеширование второго уровня реализовано в виде абстракции, то есть необходимо предоставить любую ее реализацию. 
Например, можно использовать следующих провайдеров: Ehcache, OSCache, SwarmCache, JBoss TreeCache. 

Для Hibernate требуется только реализация интерфейса org.hibernate.cache.spi.RegionFactory, который инкапсулирует все детали, 
относящиеся к конкретным провайдерам. По сути RegionFactory действует как мост между Hibernate и поставщиками кеша. 

В качестве примера воспользуемся Ehcache. Для этого:
+ добавим мавен-зависимость кеш-провайдера нужной версии;
+ включим кеш второго уровня и определить конкретного провайдера;
   `hibernate.cache.use_second_level_cache=true`
   `hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory`
+ установим у нужных сущностей JPA-аннотацию @Cacheable, обозначающую, что сущность нужно кешировать, и 
Hibernate-аннотацию @Cache, настраивающую детали кеширования, у которой в качестве параметра указать стратегию параллельного 
+ доступа.

Стратегии параллельного доступа к объектам:
   
Проблема заключается в том, что кеш второго уровня доступен из нескольких сессий сразу и несколько потоков программы могут 
одновременно в разных транзакциях работать с одним и тем же объектом. Следовательно, надо как-то обеспечивать их одинаковым 
представлением этого объекта.
+ `READ_ONLY`: Используется только для сущностей, которые никогда не изменяются (будет выброшено исключение, если 
попытаться обновить такую сущность). Просто и производительно. Подходит для некоторых статических данных, которые не меняются.

+ `NONSTRICT_READ_WRITE`: Кеш обновляется после совершения транзакции, которая изменила данные в БД и закоммитила их.
Таким образом, строгая согласованность не гарантируется, и существует небольшое временное окно между обновлением данных 
в БД и обновлением тех же данных в кеше, во время которого параллельная транзакция может получить из кеша устаревшие данные.
+ 
+ `READ_WRITE`: Гарантирует строгую согласованность, которая достигается за счет «мягких» блокировок: когда обновляется 
кешированная сущность, на нее накладывается мягкая блокировка, которая снимается после коммита транзакции. Все параллельные 
транзакции, которые пытаются получить доступ к записям в кеше с наложенной мягкой блокировкой, не смогут их прочитать или записать 
и отправят запрос в БД. Ehcache использует эту стратегию по умолчанию.

+ `TRANSACTIONAL`: полноценное разделение транзакций. Каждая сессия и каждая транзакция видят объекты, словно они 
работали с ними последовательно одна транзакция за другой. Плата за это – блокировки и потеря производительности.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Что такое JPQL/HQL и чем он отличается от SQL?

__Hibernate Query Language (HQL)__ и __Java Persistence Query Language (JPQL)__ являются объектно-ориентированными языками
запросов, схожими по природе с SQL. JPQL – это подмножество HQL.
   
`JPQL` – это язык запросов, практически такой же, как SQL, но вместо имен и колонок таблиц базы данных использует имена 
классов Entity и их атрибуты. В качестве параметров запросов используются типы данных атрибутов `Entity`, а не полей баз данных. 

В отличие от `SQL` в `JPQL` есть автоматический полиморфизм, то есть каждый запрос к Entity возвращает не только объекты этого 
Entity, но и объекты всех его классов-потомков, независимо от стратегии наследования. В JPA запрос представлен в виде `javax.persistence.Query` или
`javax.persistence.TypedQuery`, полученных из `EntityManager`.

В Hibernate HQL-запрос представлен `org.hibernate.query.Query,` полученный из Session. Если HQL является именованным 
запросом, то будет использоваться `Session#getNamedQuery`, в противном случае требуется Session#createQuery.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Что такое Criteria API и для чего он используется?
Начиная с версии 5.2, Hibernate Criteria API объявлен deprecated. Вместо него рекомендуется использовать JPA Criteria API.

__JPA Criteria API__ – это актуальный API, используемый только для выборки (select) сущностей из БД в более объектно-ориентированном стиле.

Основные преимущества JPA Criteria API:
+ ошибки могут быть обнаружены во время компиляции;
+ позволяет динамически формировать запросы на этапе выполнения приложения.

Основные недостатки:
+ нет контроля над запросом, сложно отловить ошибку;
+ влияет на производительность, множество классов.

Для динамических запросов фрагменты кода создаются во время выполнения, поэтому JPA Criteria API является предпочтительней.

Некоторые области применения `Criteria API`:
+ поддерживает проекцию, которую можно использовать для агрегатных функций вроде `sum()`, `min()`, `max()` и т. д.;
+ может использовать ProjectionList для извлечения данных только из выбранных колонок;
+ может быть использована для join запросов с помощью соединения нескольких таблиц, используя методы `createAlias()`, 
`setFetchMode()` и `setProjection()`;
+ поддерживает выборку результатов согласно условиям (ограничениям). Для этого используется метод add(), с помощью 
которого добавляются ограничения(Restrictions).
+ позволяет добавлять порядок (сортировку) к результату с помощью метода addOrder().
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Расскажите про проблему N+1 Select и путях ее решения

Проблема N+1 запросов возникает, когда получение данных из БД выполняется за N дополнительных SQL-запросов для извлечения 
тех же данных, которые могли быть получены при выполнении основного SQL-запроса.

1. `JOIN FETCH`

И при `FetchType.EAGER`, и при `FetchType.LAZY` поможет JPQL-запрос с `JOIN FETCH`.

Опцию `«FETCH»` можно использовать в `JOIN(INNER JOIN или LEFT JOIN)` для выборки связанных объектов в одном запросе 
вместо дополнительных запросов для каждого доступа к ленивым полям объекта.

Лучший вариант решения для простых запросов (1-3 уровня вложенности связанных объектов).

```jpaql
select pc
from PostComment pc
join fetch pc.post p
```

2. `EntityGraph`

Если нужно получить много данных через jpql-запрос, лучше всего использовать EntityGraph.

3. `@Fetch(FetchMode.SUBSELECT)`

Аннотация Hibernate. Можно использовать только с коллекциями. Будет сделан один sql-запрос для получения корневых сущностей 
и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения 
связанных коллекций:

```java
@Fetch(value = FetchMode.SUBSELECT)
private Set<Order> orders = new HashSet<>();
```

4. `Batch fetching`

Аннотация Hibernate, в JPA ее нет. Указывается над классом сущности или над полем коллекции с ленивой загрузкой. Будет 
сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым поляьи-коллекциям, 
то выполнится еще один запрос для получения связанных коллекций.
   
Количество загружаемых сущностей указывается в аннотации.
```java
@BatchSize(size=5)
private Set<Order> orders = new HashSet<>();
```
5. `HibernateSpecificMapping, SqlResultSetMapping`

Рекомендуется использовать для нативных запросов.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Что такое EntityGraph? Как и для чего их использовать?

Основная цель `JPA Entity Graph` – улучшить производительность в рантайме при загрузке базовых полей сущности и связанных 
сущностей и коллекций.

Hibernate загружает весь граф в одном SELECT-запросе, то есть все указанные связи от нужной сущности. Если необходимо 
загрузить дополнительные сущности, находящиеся в связанных сущностях, используется `Subgraph`.

EntityGraph можно определить с помощью аннотации `@NamedEntityGraph` для `Entity`, она определяет уникальное имя и список 
атрибутов (`attributeNodes`), которые должны быть загружены с использованеим entityManager из JPA API:
```java
EntityGraph<Post> entityGraph = entityManager.createEntityGraph(Post.class);
entityGraph.addAttributeNodes("subject");
entityGraph.addAttributeNodes("user");
entityGraph.addSubgraph("comments").addAttributeNodes("user");
```

JPA определяет два свойства или подсказки, с помощью которых Hibernate может выбирать стратегию извлечения графа сущностей во время выполнения:
+ `fetchgraph` – все атрибуты, перечисленные в `EntityGraph`, меняют `fetchType` на `EAGER`, все остальные – на `LAZY`;
+ `loadgraph` – все атрибуты, перечисленные в `EntityGraph`, меняют `fetchType` на `EAGER`, все остальные сохраняют свой `fetchType`. 
С помощью NamedSubgraph можно изменить fetchType вложенных объектов Entity.
   
Загрузить EntityGraph можно тремя способами:
1. Используя перегруженный метод `find()`, который принимает Map с настройками `EntityGraph`.
2. Используя `JPQL` и передав подсказку через `setHint()`.
3. С помощью `Criteria API`.
___
+ <span style="display: inline-block; float: right">[содержание](#hibernate)</span>

## Мемоизация
__Memoization__ – вариант кеширования, заключающийся в том, что для функции создается таблица результатов. 
Результат функции, вычисленной при определенных значениях параметров, заносится в эту таблицу. В дальнейшем результат 
берется из данной таблицы.
   
Эта техника позволяет за счет использования дополнительной памяти ускорить работу программы.

Можно применить только к функциям, которые являются:
+ детерминированными (т. е. при одном и том же наборе параметров функции должны возвращать одинаковое значение);
+ без побочных эффектов (т. е. не должны влиять на состояние системы).
   
В Java наиболее подходящей кандидатурой на роль хранилища является интерфейс Map.

Сложность операций get, put, contains равна O(1). Это позволяет гарантировать ограничение задержки при выполнении мемоизации.

Мемоизация реализована в библиотеке `ehcache`.