#### [Оглавление](../README.md)

# Паттерны
+ [Что такое _«шаблон проектирования»_?](#что-такое-шаблон-проектирования-)
+ [Назовите основные характеристики шаблонов](#назовите-основные-характеристики-шаблонов)
+ [Типы шаблонов проектирования](#типы-шаблонов-проектирования)
+ [Приведите примеры основных шаблонов проектирования](#приведите-примеры-основных-шаблонов-проектирования)
+ [Приведите примеры порождающих шаблонов проектирования](#приведите-примеры-порождающих-шаблонов-проектирования)
+ [Приведите примеры структурных шаблонов проектирования](#приведите-примеры-структурных-шаблонов-проектирования)
+ [Приведите примеры поведенческих шаблонов проектирования](#приведите-примеры-поведенческих-шаблонов-проектирования)
+ [Что такое _«антипаттерн»_? Какие антипаттерны вы знаете?](#что-такое-антипаттерн--какие-антипаттерны-вы-знаете)
+ [Что такое _Dependency Injection_?](#что-такое-dependency-injection-)
+ [Назовите три основные группы паттернов](#назовите-три-основные-группы-паттернов)
+ [Расскажите про паттерн «Одиночка» (Singleton)](#расскажите-про-паттерн-одиночка--singleton-)
+ [Расскажите про паттерн «Строитель» (Builder)](#расскажите-про-паттерн-строитель--builder-)
+ [Расскажите про паттерн «Фабричный метод» (Factory Method)](#расскажите-про-паттерн-фабричный-метод--factory-method-)
+ [Расскажите про паттерн «Абстрактная фабрика» (Abstract Factory)](#расскажите-про-паттерн-абстрактная-фабрика--abstract-factory-)
+ [Расскажите про паттерн «Прототип» (Prototype)](#расскажите-про-паттерн-прототип--prototype-)
+ [Расскажите про паттерн «Адаптер» (Adapter)](#расскажите-про-паттерн-адаптер--adapter-)
+ [Расскажите про паттерн «Декоратор» (Decorator)](#расскажите-про-паттерн-декоратор--decorator-)
+ [Расскажите про паттерн «Заместитель» (Proxy)](#расскажите-про-паттерн-заместитель--proxy-)
+ [Расскажите про паттерн «Итератор» (Iterator)](#расскажите-про-паттерн-итератор--iterator-)
+ [Расскажите про паттерн «Шаблонный метод» (Template Method)](#расскажите-про-паттерн-шаблонный-метод--template-method-)
+ [Расскажите про паттерн «Цепочка обязанностей» (Chain of Responsibility)](#расскажите-про-паттерн-цепочка-обязанностей--chain-of-responsibility-)
+ [Какие паттерны используются в Spring Framework?](#какие-паттерны-используются-в-spring-framework)
+ [Какие паттерны используются в Hibernate?](#какие-паттерны-используются-в-hibernate)
+ [Шаблоны GRASP: Low Coupling (низкая связанность) и High Cohesion (высокая сплоченность)](#шаблоны-grasp--low-coupling--низкая-связанность--и-high-cohesion--высокая-сплоченность-)
+ [Расскажите про паттерн Saga](#расскажите-про-паттерн-saga)

_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Что такое _«шаблон проектирования»_?

__Шаблон (паттерн) проектирования (design pattern)__ — это проверенное и готовое к использованию решение. 
Это не класс и не библиотека, которую можно подключить к проекту, это нечто большее - он не зависит от языка 
программирования, не является законченным образцом, который может быть прямо преобразован в код и может быть 
реализован по-разному в разных языках программирования.

Плюсы использования шаблонов:
+ снижение сложности разработки за счёт готовых абстракций для решения целого класса проблем.
+ облегчение коммуникации между разработчиками, позволяя ссылаться на известные шаблоны.
+ унификация деталей решений: модулей и элементов проекта.
+ возможность отыскав удачное решение, пользоваться им снова и снова.
+ помощь в выборе выбрать наиболее подходящего варианта проектирования.

Минусы:
+ слепое следование некоторому выбранному шаблону может привести к усложнению программы.
+ желание попробовать некоторый шаблон в деле без особых на то оснований.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Назовите основные характеристики шаблонов

+ __Имя__ - все шаблоны имеют уникальное имя, служащее для их идентификации;
+ __Назначение__	назначение данного шаблона;
+ __Задача__ - задача, которую шаблон позволяет решить;
+ __Способ решения__ - способ, предлагаемый в шаблоне для решения задачи в том контексте, где этот шаблон был найден;
+ __Участники__	- сущности, принимающие участие в решении задачи;
+ __Следствия__	- последствия от использования шаблона как результат действий, выполняемых в шаблоне;
+ __Реализация__ - возможный вариант реализации шаблона.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Типы шаблонов проектирования

+ Основные (Fundamental) - основные строительные блоки других шаблонов. Большинство других шаблонов использует эти шаблоны в той или иной форме.
+ Порождающие шаблоны (Creational) — шаблоны проектирования, которые абстрагируют процесс создание экземпляра. Они позволяют сделать систему независимой от способа создания, композиции и представления объектов. Шаблон, порождающий классы, использует наследование, чтобы изменять созданный объект, а шаблон, порождающий объекты, делегирует создание объектов другому объекту.
+ Структурные шаблоны (Structural) определяют различные сложные структуры, которые изменяют интерфейс уже существующих объектов или его реализацию, позволяя облегчить разработку и оптимизировать программу.
+ Поведенческие шаблоны (Behavioral) определяют взаимодействие между объектами, увеличивая таким образом его гибкость.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Приведите примеры основных шаблонов проектирования

+ __Делегирование (Delegation pattern)__ - Сущность внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту.
+ __Функциональный дизайн (Functional design)__ - Гарантирует, что каждая сущность имеет только одну обязанность и исполняет её с минимумом побочных эффектов на другие.
+ __Неизменяемый интерфейс (Immutable interface)__ - Создание неизменяемого объекта.
+ __Интерфейс (Interface)__ - Общий метод структурирования сущностей, облегчающий их понимание.
+ __Интерфейс-маркер (Marker interface)__ - В качестве атрибута (как пометки объектной сущности) применяется наличие или отсутствие реализации интерфейса-маркера. В современных языках программирования вместо этого применяются атрибуты или аннотации.
+ __Контейнер свойств (Property container)__ - Позволяет добавлять дополнительные свойства сущности в контейнер внутри себя, вместо расширения новыми свойствами.
+ __Канал событий (Event channel)__ - Создаёт централизованный канал для событий. Использует сущность-представитель для подписки и сущность-представитель для публикации события в канале. Представитель существует отдельно от реального издателя или подписчика. Подписчик может получать опубликованные события от более чем одной сущности, даже если он зарегистрирован только на одном канале.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Приведите примеры порождающих шаблонов проектирования

+ __Абстрактная фабрика (Abstract factory)__ - Класс, который представляет собой интерфейс для создания других классов.
+ __Строитель (Builder)__ - Класс, который представляет собой интерфейс для создания сложного объекта.
+ __Фабричный метод (Factory method)__ - Делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.
+ __Прототип (Prototype)__ - Определяет интерфейс создания объекта через клонирование другого объекта вместо создания через конструктор.
+ __Одиночка (Singleton)__ - Класс, который может иметь только один экземпляр.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Приведите примеры структурных шаблонов проектирования

+ __Адаптер (Adapter)__ - Объект, обеспечивающий взаимодействие двух других объектов, один из которых использует, а другой предоставляет несовместимый с первым интерфейс.
+ __Мост (Bridge)__ - Структура, позволяющая изменять интерфейс обращения и интерфейс реализации класса независимо.
+ __Компоновщик (Composite)__ - Объект, который объединяет в себе объекты, подобные ему самому.
+ __Декоратор (Decorator)__ - Класс, расширяющий функциональность другого класса без использования наследования.
+ __Фасад (Facade)__ - Объект, который абстрагирует работу с несколькими классами, объединяя их в единое целое.
+ __Приспособленец (Flyweight)__ - Это объект, представляющий себя как уникальный экземпляр в разных местах программы, но по факту не являющийся таковым.
+ __Заместитель (Proxy)__ - Объект, который является посредником между двумя другими объектами, и который реализует/ограничивает доступ к объекту, к которому обращаются через него.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Приведите примеры поведенческих шаблонов проектирования

+ __Цепочка обязанностей (Chain of responsibility)__ - Предназначен для организации в системе уровней ответственности.
+ __Команда (Command)__ - Представляет действие. Объект команды заключает в себе само действие и его параметры.
+ __Интерпретатор (Interpreter)__ - Решает часто встречающуюся, но подверженную изменениям, задачу.
+ __Итератор (Iterator)__ - Представляет собой объект, позволяющий получить последовательный доступ к элементам объекта-агрегата без использования описаний каждого + __из объектов, входящих в состав агрегации.
+ __Посредник (Mediator)__ - Обеспечивает взаимодействие множества объектов, формируя при этом слабую связанность и избавляя объекты от необходимости явно ссылаться друг на друга.
+ __Хранитель (Memento)__ - Позволяет, не нарушая инкапсуляцию зафиксировать и сохранить внутренние состояния объекта так, чтобы позднее восстановить его в этих состояниях.
+ __Наблюдатель (Observer)__ - Определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом событии.
+ __Состояние (State)__ - Используется в тех случаях, когда во время выполнения программы объект должен менять своё поведение в зависимости от своего состояния.
+ __Стратегия (Strategy)__ - Предназначен для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости.
+ __Шаблонный метод (Template method)__ - Определяет основу алгоритма и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.
+ __Посетитель (Visitor)__ - Описывает операцию, которая выполняется над объектами других классов. При изменении класса Visitor нет необходимости изменять обслуживаемые классы.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Что такое _«антипаттерн»_? Какие антипаттерны вы знаете?

__Антипаттерн (anti-pattern)__ — это распространённый подход к решению класса часто встречающихся проблем, являющийся 
неэффективным, рискованным или непродуктивным.

__Poltergeists (полтергейсты)__ - это классы с ограниченной ответственностью и ролью в системе, чьё единственное 
предназначение — передавать информацию в другие классы. Их эффективный жизненный цикл непродолжителен. Полтергейсты 
нарушают стройность архитектуры программного обеспечения, создавая избыточные (лишние) абстракции, они чрезмерно 
запутанны, сложны для понимания и трудны в сопровождении. Обычно такие классы задумываются как классы-контроллеры, 
которые существуют только для вызова методов других классов, зачастую в предопределенной последовательности.

Признаки появления и последствия антипаттерна
+ Избыточные межклассовые связи.
+ Временные ассоциации.
+ Классы без состояния (содержащие только методы и константы).
+ Временные объекты и классы (с непродолжительным временем жизни).
+ Классы с единственным методом, который предназначен только для создания или вызова других классов посредством временной ассоциации.
+ Классы с именами методов в стиле «управления», такие как startProcess.

Типичные причины
+ Отсутствие объектно-ориентированной архитектуры (архитектор не понимает объектно-ориентированной парадигмы).
+ Неправильный выбор пути решения задачи.
+ Предположения об архитектуре приложения на этапе анализа требований (до объектно-ориентированного анализа) могут также вести к проблемам на подобии этого антипаттерна.

__Внесенная сложность (Introduced complexity)__: Необязательная сложность дизайна. Вместо одного простого класса выстраивается целая иерархия интерфейсов и классов. Типичный пример «Интерфейс - Абстрактный класс - Единственный класс реализующий интерфейс на основе абстрактного».

__Инверсия абстракции (Abstraction inversion)__: Сокрытие части функциональности от внешнего использования, в надежде на то, что никто не будет его использовать.

__Неопределённая точка зрения (Ambiguous viewpoint)__: Представление модели без спецификации её точки рассмотрения.

__Большой комок грязи (Big ball of mud)__: Система с нераспознаваемой структурой.

__Божественный объект (God object)__: Концентрация слишком большого количества функций в одной части системы (классе).

__Затычка на ввод данных (Input kludge)__: Забывчивость в спецификации и выполнении поддержки возможного неверного ввода.

__Раздувание интерфейса (Interface bloat)__: Разработка интерфейса очень мощным и очень сложным для реализации.

__Волшебная кнопка (Magic pushbutton)__: Выполнение результатов действий пользователя в виде неподходящего (недостаточно абстрактного) интерфейса. Например, написание прикладной логики в обработчиках нажатий на кнопку.

__Перестыковка (Re-Coupling)__: Процесс внедрения ненужной зависимости.

__Дымоход (Stovepipe System)__: Редко поддерживаемая сборка плохо связанных компонентов.

__Состояние гонки (Race hazard)__: непредвидение возможности наступления событий в порядке, отличном от ожидаемого.

__Членовредительство (Mutilation)__: Излишнее «затачивание» объекта под определенную очень узкую задачу таким образом, что он не способен будет работать с никакими иными, пусть и очень схожими задачами.

__Сохранение или смерть (Save or die)__: Сохранение изменений лишь при завершении приложения.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Что такое _Dependency Injection_?

__Dependency Injection (внедрение зависимости)__ - это набор паттернов и принципов разработки програмного обеспечения,
которые позволяют писать слабосвязный код. В полном соответствии с принципом единой обязанности объект отдаёт заботу о 
построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

### Назовите три основные группы паттернов

+ __Порождающие__ – отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов без внесения в программу лишних зависимостей.
+ __Структурные__ – отвечают за построение удобных в поддержке иерархий классов.
+ __Поведенческие__ – заботятся об эффективной коммуникации между объектами.

Основные – основные строительные блоки, используемые для построения других шаблонов. Например, интерфейс.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Расскажите про паттерн «Одиночка» (Singleton)

Порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

Конструктор помечается как private, а для создания нового объекта Singleton использует специальный метод getInstance(). 
Он либо создает объект, либо отдаёе существующий объект, если он уже был создан.
```java
private static Singleton instance;

public static Singleton getInstance() {
    if (instance == null) {
        instance = new Singleton();
    }
    return instance;
}
```
Плюсы:
+ можно не создавать множество объектов для ресурсоемких задач, а пользоваться одним.
Минусы:
+ нарушает принцип единой ответственности, так как его могут использовать множество объектов.
Почему считается антипаттерном?
+ нельзя тестировать с помощью mock, но можно использовать powerMock;
+ нарушает принцип единой ответственности;
+ нарушает Open/Close принцип, его нельзя расширить.
Можно ли его синхронизировать без synchronized у метода?
1. Можно сделать его Enum (eager). Это статический final класс с константами. JVM загружает final и static классы на 
этапе компиляции, а значит несколько потоков не могут создать несколько инстансов.
2. C помощью `double checked locking (lazy)`. `Synchronized` внутри метода:
```java
private static volatile Singleton instance;
public static Singleton getInstance() {
    Singleton localInstance = instance;
    
    if (localInstance == null) { // first check
        synchronized (Singleton.class) {
            localInstance = instance;
            if (localInstance == null) { // second check
                instance = localInstance = new Singleton();
            }
        }
    }
return localInstance;
}
 ```
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

### Расскажите про паттерн «Строитель» (Builder)

Порождающий паттерн, который позволяет создавать сложные объекты пошагово.

Строитель дает возможность использовать один и тот же код для получения разных представлений одного объекта.

Паттерн предлагает вынести конструирование объекта за пределы его собственного класса, поручив это дело отдельным объектам, 
называемым строителями.

Процесс конструирования объекта разбит на отдельные шаги (например, построитьСтены, вставитьДвери). Чтобы создать объект, 
нужно поочередно вызывать методы строителя. Причем не нужно запускать все шаги, а только те, что нужны для производства объекта
определенной конфигурации.

Можно пойти дальше и выделить вызовы методов строителя в отдельный класс, называемый Директором. В этом случае Директор 
будет задавать порядок шагов строительства, а строитель – выполнять их.

Плюсы:
+ позволяет использовать один и тот же код для создания различных объектов;
+ изолирует сложный код сборки объектов от его основной бизнес-логики.

Минусы:
+ усложняет код программы из-за введения дополнительных классов.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Расскажите про паттерн «Фабричный метод» (Factory Method)

Порождающий шаблон проектирования, в котором подклассы имплементируют общий интерфейс с методом для создания объектов. 
Переопределенный метод в каждом наследнике возвращает нужный вариант объекта.

Объекты все равно будут создаваться при помощи new, но делать это будет фабричный метод. Таким образом можно переопределить 
фабричный метод в подклассе, чтобы изменить тип создаваемого продукта.
   
Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить 
объекты различных классов, следующих одному и тому же интерфейсу.

Плюсы:
+ выделяет код производства объектов в одно место, упрощая поддержку кода;
+ реализует принцип открытости/закрытости.

Минусы:
+ может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой подкласс создателя.
   
Пример: SessionFactory в Hibernate.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Расскажите про паттерн «Абстрактная фабрика» (Abstract Factory)

Порождающий паттерн проектирования, который представляет собой интерфейс для создания других классов, не привязываясь к 
конкретным классам создаваемых объектов.

Абстрактная фабрика предлагает выделить общие интерфейсы для отдельных продуктов, составляющих семейства. Так, 
все вариации кресел получат общий интерфейс Кресло, все диваны реализуют интерфейс Диван и так далее. Далее создается 
абстрактная фабрика – общий интерфейс, который содержит фабричные методы создания всех продуктов семейства (например, 
создатьКресло, создатьДиван и создатьСтолик). Эти операции должны возвращать абстрактные типы продуктов, представленные 
интерфейсами, которые выделили ранее – Кресла, Диваны и Столики.

Плюсы:
+ гарантированно будет создаваться тип одного семейства.
Минусы:
+ усложняет код программы из-за введения множества дополнительных классов.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Расскажите про паттерн «Прототип» (Prototype)

Порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации.

Паттерн поручает создание копий самим копируемым объектам. Он вводит общий интерфейс с методом clone для всех объектов, 
поддерживающих клонирование. Реализация этого метода в разных классах очень схожа. Метод создает новый объект текущего 
класса и копирует в него значения всех полей собственного объекта.

Плюсы:
+ позволяет клонировать объекты, не привязываясь к их конкретным классам.

Минусы:
+ сложно клонировать составные объекты, имеющие ссылки на другие объекты.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Расскажите про паттерн «Адаптер» (Adapter)

Структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.

Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен д
ругому объекту. При этом адаптер оборачивает один из объектов так, что другой объект даже не знает о наличии первого.

Плюсы:
+ отделяет и скрывает от клиента подробности преобразования различных интерфейсов.

Минусы:
+ усложняет код программы из-за введения дополнительных классов.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Расскажите про паттерн «Декоратор» (Decorator)

Структурный паттерн проектирования, который позволяет добавлять объектам новую функциональность, оборачивая их в полезные «обертки».

Целевой объект помещается в другой объект-обертку, который запускает базовое поведение обернутого объекта, а затем 
добавляет к результату что-то свое. Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с 
каким объектом работать – чистым или обернутым. Можно использовать несколько разных оберток одновременно – результат 
будет иметь объединенное поведение всех оберток сразу.

Адаптер не меняет состояния объекта, а декоратор может менять.
Плюсы:
+ большая гибкость, чем у наследования.

Минусы:
+ труднее конфигурировать многократно обернутые объекты.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Расскажите про паттерн «Заместитель» (Proxy)

Структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители, 
которые перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

Заместитель предлагает создать новый класс-дублер, имеющий тот же интерфейс, что и оригинальный служебный объект. 
При получении запроса от клиента объект-заместитель сам бы создавал экземпляр служебного объекта, выполняя промежуточную 
логику, которая выполнялась бы до (или после) вызовов этих же методов в настоящем объекте.

Плюсы:
+ позволяет контролировать сервисный объект незаметно для клиента.

Минусы:
+ увеличивает время отклика от сервиса.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Расскажите про паттерн «Итератор» (Iterator)

Поведенческий паттерн проектирования, который дает возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.

Идея состоит в том, чтобы вынести поведение обхода коллекции из самой коллекции в отдельный класс.

Детали: создается итератор и интерфейс, который возвращает итератор. В классе, в котором надо будет вызывать итератор, 
имплементируем интерфейс, возвращающий итератор, а сам итератор делаем там нестатическим вложенным классом, так как он 
нигде использоваться больше не будет.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Расскажите про паттерн «Шаблонный метод» (Template Method)

Поведенческий паттерн проектирования, который пошагово определяет алгоритм и позволяет наследникам переопределять 
некоторые шаги алгоритма, не изменяя его структуру в целом.
   
Паттерн предлагает разбить алгоритм на последовательность шагов, описать эти шаги в отдельных методах и вызывать их в 
одном шаблонном методе друг за другом. Для описания шагов используется абстрактный класс. Общие шаги можно будет 
описать прямо в абстрактном классе. Это позволит подклассам переопределять некоторые шаги алгоритма, оставляя без 
изменений его структуру и остальные шаги, которые для этого подкласса не так важны.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Расскажите про паттерн «Цепочка обязанностей» (Chain of Responsibility)

Поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. 
Каждый обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

Базируется на том, чтобы превратить каждую проверку в отдельный класс с единственным методом выполнения. Данные 
запроса, над которым происходит проверка, будут передаваться в метод как аргументы.

Каждый из методов будет иметь ссылку на следующий метод-обработчик, что образует цепь.

Таким образом, при получении запроса обработчик сможет не только сам что-то с ним сделать, но и передать обработку
следующему объекту в цепочке. Может и не передавать, если проверка в одном из методов не прошла.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Какие паттерны используются в Spring Framework?
+ `Singleton` – Bean scopes;
+ `Factory` – Bean Factory classes;
+ `Prototype` – Bean scopes;
+ `Adapter` – Spring Web and Spring MVC;
+ `Proxy` – Spring Aspect Oriented Programming support;
+ `Template Method` – JdbcTemplate, HibernateTemplate etc;
+ `Front Controller` – Spring MVC DispatcherServlet;
+ `DAO` – Spring Data Access Object support;
+ `Dependency Injection`.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Какие паттерны используются в Hibernate?

+ `Domain Model` – объектная модель предметной области, включающая в себя как поведение, так и данные;
+ `Data Mapper` – слой мапперов (Mappers), который передает данные между объектами и базой данных, сохраняя их независимыми друг от друга и себя;
+ `Proxy` – применяется для ленивой загрузки;
+ `Factory` – используется в SessionFactory.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Шаблоны GRASP: Low Coupling (низкая связанность) и High Cohesion(высокая сплоченность)

`Low Coupling `– части системы, которые изменяются вместе, должны находиться близко друг к другу.

`High Cohesion` – если возвести Low Coupling в абсолют, то можно прийти к тому, чтобы разместить всю функциональность в 
одном единственном классе. В таком случае связей не будет вообще, но в этот класс попадет совершенно несвязанная между 
собой бизнес-логика.

Принцип High Cohesion говорит следующее: части системы, которые изменяются параллельно, должны иметь как можно меньше 
зависимостей друг на друга. 

`Low Coupling` и `High Cohesion `представляют из себя два связанных между собой паттерна, рассматривать которые имеет 
смысл только вместе. Их суть: система должна состоять из слабо связанных классов, которые содержат связанную бизнес-логику. 
Соблюдение этих принципов позволяет удобно переиспользовать созданные классы, не теряя понимания о их зоне ответственности.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#паттерны)</span>

## Расскажите про паттерн Saga

__Saga__ – это механизм, обеспечивающий согласованность данных в микросервисах без применения распределенных транзакций.
   
Для каждой системной команды, которой надо обновлять данные в нескольких сервисах, создается некоторая сага. Сага 
представляет из себя некоторый «чек-лист», состоящий из последовательных локальных ACID-транзакций, каждая из которых 
обновляет данные в одном сервисе. Для обработки сбоев применяется компенсирующая транзакция. Такие транзакции выполняются 
в случае сбоя на всех сервисах, на которых локальные транзакции выполнились успешно.

Типов транзакций в саге четыре:
+ компенсирующая – отменяет изменение, сделанное локальной транзакцией; 
+ компенсируемая – это транзакция, которую необходимо компенсировать (отменить) в случае, если последующие транзакции завершаются неудачей; 
+ поворотная – транзакция, определяющая успешность всей саги: если она выполняется успешно, то сага гарантированно дойдет до конца; 
+ повторяемая – идет после поворотной и гарантированно завершается успехом
