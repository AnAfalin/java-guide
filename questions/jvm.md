#### [Оглавление](../README.md)

# JVM
+ [Что такое JDK?](#что-такое-JDK)
+ [Что такое JRE?](#что-такое-JRE)
+ [Что такое JVM?](#что-такое-JVM)
+ [Что такое _byte code_?](#что-такое-byte-code)
+ [Classloader](#classloader)
+ [Что такое JIT?](#что-такое-JIT)

_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#jvm)</span>

## Что такое JDK?

___JDK, Java Development Kit (комплект разработки на Java)___ – JRE и набор инструментов разработчика приложений на 
языке Java, включающий в себя компилятор Java, стандартные библиотеки классов Java, примеры, документацию, различные 
утилиты.

___Коротко___: JDK – среда для разработки программ на Java, включающая в себя JRE-среду для обеспечения запуска 
Java-программ, которая в свою очередь содержит JVM-интерпретатор кода Java-программ.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#jvm)</span>

## Что такое JRE?

__JRE, Java Runtime Environment (среда времени выполнения Java)__ – минимально необходимая реализация виртуальной машины 
для исполнения Java-приложений. Состоит из JVM и стандартного набора библиотек классов Java.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#jvm)</span>

## Что такое JVM?

___JVM, Java Virtual Machine (виртуальная машина Java)___ – основная часть среды времени исполнения Java (JRE). 
Виртуальная машина Java исполняет байт-код Java, предварительно созданный из исходного текста Java-программы 
компилятором Java. JVM может также использоваться для выполнения программ, написанных на других языках программирования.

_JVM_ отвечает за:

+ Загрузка, проверка и исполнение байт-кода;
+ Предоставление среды выполнения для выполнения байт-кода;
+ Управление памятью и очисткой мусора (Garbage collection);

___Виртуальная машина Java (Java Virtual Machine)___ - это механизм, предоставляющий среду выполнения для управления 
Java-кодом или приложениями.

Виртуальная машина является независимой оболочкой исполнения кода, благодаря которой возможен её запуск на любой ОС,
без влияния ОС на выполняемую программу.

JVM работает с 2мя типами данных:  примитивные типы (**primitive types**) и ссылочные типы (**reference types**).

**Примитивы**

JVM работает с примитивными значениями (целыми числами и числами с плавающей точкой). По сути, JVM - это 32-битная 
машина.

Типы `long` и `double`, которые являются 64-битными, поддерживаются изначально, но занимают две единицы памяти в 
`frame's local`или стеке операндов, поскольку каждая единица составляет 32 бита.

Типы `boolean`, `byte`, `short` и `char` имеют расширенный знак (кроме `char` с нулевым расширением) и работают как 
32-разрядные целые числа, так же как и типы `int`.

Меньшие типы имеют только несколько специфических для типа инструкций для загрузки, хранения и преобразования типов.
`boolean` значение работает как 8-битное `byte` значения, где 0 представляет значение **false**, а 1 - значение **true**.

**Типы ссылок и значения**

Существует три типа ссылочных типов: типы классов, типы массивов и типы интерфейсов.

Их значения являются ссылками на динамически создаваемые экземпляры классов, массивы или экземпляры классов,
которые реализуют интерфейсы соответственно.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#jvm)</span>

## Что такое byte code?

Байт-код Java – набор инструкций, скомпилированный компилятором, исполняемый JVM, имеется уже
около 200 инструкций, 56 в запасе. 1 инструкция = 1 байту.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#jvm)</span>

## Classloader

Загрузчик классов является частью JRE, которая динамически загружает Java классы в JVM.

Основа работы с классами в Java – классы-загрузчики, обычные Java-объекты, предоставляющие интерфейс для поиска и 
создания объекта класса по его имени во время работы приложения.

Обычно классы загружаются только по запросу. Система исполнения в Java не должна знать о файлах и файловых системах
благодаря загрузчику классов. **Делегирование является важной концепцией**, которую выполняет загрузчик. Загрузчик 
классов отвечает за поиск библиотек, чтение их содержимого и загрузку классов, содержащихся в библиотеках.

Эта **загрузка** обычно выполняется **«по требованию»**, поскольку она не происходит до тех пор, пока программа не 
вызовет класс.
**Класс с именем может быть загружен только один раз данным загрузчиком классов.**

При запуске JVM, используются три загрузчика классов:
* Bootstrap class loader (Загрузчик класса Bootstrap)
* Extensions class loader (Загрузчик класса расширений)
* System class loader (Системный загрузчик классов)

**Загрузчик класса Bootstrap** загружает основные библиотеки Java, расположенные в папке `<JAVA_HOME>/jre/lib`.
Этот загрузчик является частью ядра JVM, написан на нативном коде.

**Загрузчик класса расширений** загружает код в каталоги расширений
(`<JAVA_HOME>/jre/lib/ext`, или любой другой каталог, указанный системным свойством `java.ext.dirs`).

**Системный загрузчик** загружает код, найденный в `java.class.path`, который сопоставляется с переменной среды 
`CLASSPATH`.
Это реализуется классом `sun.misc.Launcher$AppClassLoader`.

Загрузчик классов выполняет три основных действия в строгом порядке:
* Загрузка: находит и импортирует двоичные данные для типа.
* Связывание: выполняет проверку, подготовку и (необязательно) разрешение.
    - Проверка: обеспечивает правильность импортируемого типа.
    - Подготовка: выделяет память для переменных класса и инициализация памяти значениями по умолчанию.
    - Разрешение: преобразует символические ссылки из типа в прямые ссылки.
* Инициализация: вызывает код Java, который инициализирует переменные класса их правильными начальными значениями.

**Пользовательский загрузчик классов**

Загрузчик классов написан на Java. Поэтому возможно создать свой собственный загрузчик классов, не понимая тонких 
деталей JVM.
У каждого загрузчика классов Java есть родительский загрузчик классов, определенный при создании экземпляра нового
загрузчика классов или в качестве системного загрузчика классов по умолчанию для виртуальной машины.

Что делает возможным следующее:
* загружать или выгружать классы во время выполнения (например, динамически загружать библиотеки во время выполнения, 
даже из ресурса HTTP).
  Это важная особенность для:
    - реализация скриптовых языков;
    - использование bean builders;
    - добавить пользовательское расширение;
    - позволяя нескольким пространствам имен общаться. Например, это одна из основ протоколов CORBA / RMI;
* изменить способ загрузки байт-кода (например, можно использовать зашифрованный байт-код класса Java);
* модифицировать загруженный байт-код (например, для переплетения аспектов во время загрузки при использовании 
аспектно-ориентированного программирования);

Основа работы с классами в Java — классы-загрузчики, обычные Java-объекты, предоставляющие интерфейс для поиска и 
создания объекта класса по его имени во время работы приложения.

В начале работы программы создается 3 основных загрузчика классов:

+ __базовый загрузчик (bootstrap/primordial)__. Загружает основные системные и внутренние классы JDK 
+ (_Core API_ - пакеты `java.*` (`rt.jar` и `i18n.jar`) . Важно заметить, что базовый загрузчик является _«Изначальным»_ 
+ или _«Корневым»_ и частью JVM, вследствие чего его нельзя создать внутри кода программы.
+ __загрузчик расширений (extension)__. Загружает различные пакеты расширений, которые располагаются в директории 
+ `<JAVA_HOME>/lib/ext` или другой директории, описанной в системном параметре `java.ext.dirs`. Это позволяет обновлять 
+ и добавлять новые расширения без необходимости модифицировать настройки используемых приложений. Загрузчик расширений 
+ реализован классом `sun.misc.Launcher$ExtClassLoader`.
+ __системный загрузчик (system/application)__. Загружает классы, пути к которым указаны в переменной окружения 
+ `CLASSPATH` или пути, которые указаны в командной строке запуска JVM после ключей `-classpath` или `-cp`. Системный 
+ загрузчик реализован классом `sun.misc.Launcher$AppClassLoader`.

Загрузчики классов являются иерархическими: каждый из них (кроме базового) имеет родительский загрузчик и в большинстве
случаев, перед тем как попробовать загрузить класс самостоятельно, он посылает вначале запрос родительскому загрузчику 
загрузить указанный класс. Такое делегирование позволяет загружать классы тем загрузчиком, который находится ближе всего
к базовому в иерархии делегирования. Как следствие поиск классов будет происходить в источниках в порядке их доверия: 
сначала в библиотеке _Core API_, потом в папке расширений, потом в локальных файлах `CLASSPATH`.

Процесс загрузки класса состоит из трех частей:

+ _Loading_ – на этой фазе происходит поиск и физическая загрузка файла класса в определенном источнике (в зависимости 
от загрузчика). Этот процесс определяет базовое представление класса в памяти. На этом этапе такие понятия как 
«методы», «поля» и т.д. пока не известны.
+ _Linking_ – процесс, который может быть разбит на 3 части:
  + _Bytecode verification_ – проверка байт-кода на соответствие требованиям, определенным в спецификации JVM.
  + _Class preparation_ – создание и инициализация необходимых структур, используемых для представления полей, методов,
  + реализованных интерфейсов и т.п., определенных в загружаемом классе.
  + _Resolving_ – загрузка набора классов, на которые ссылается загружаемый класс.
+ _Initialization_ – вызов статических блоков инициализации и присваивание полям класса значений по умолчанию.

Динамическая загрузка классов в Java имеет ряд особенностей:

+ _отложенная (lazy) загрузка и связывание классов_. Загрузка классов производится только при необходимости, что 
позволяет экономить ресурсы и распределять нагрузку.
+ _проверка корректности загружаемого кода (type safeness)_. Все действия связанные с контролем использования типов 
производятся только во время загрузки класса, позволяя избежать дополнительной нагрузки во время выполнения кода.
+ _программируемая загрузка_. Пользовательский загрузчик полностью контролирует процесс получения запрошенного класса 
— самому ли искать байт-код и создавать класс или делегировать создание другому загрузчику. Дополнительно существует 
+ возможность выставлять различные атрибуты безопасности для загружаемых классов, позволяя таким образом работать с 
кодом из ненадежных источников.
+ _множественные пространства имен_. Каждый загрузчик имеет своё пространство имён для создаваемых классов. 
Соответственно, классы, загруженные двумя различными загрузчиками на основе общего байт-кода, в системе будут 
различаться.

Существует несколько способов инициировать загрузку требуемого класса:

+ ___явный___: вызов `ClassLoader.loadClass()` или `Class.forName()` (по умолчанию используется загрузчик, создавший текущий
класс, но есть возможность и явного указания загрузчика);
+ ___неявный___: когда для дальнейшей работы приложения требуется ранее не использованный класс, JVM инициирует его загрузку.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#jvm)</span>

## Что такое JIT?

___JIT (Just-In-Time) компиляция___ - это вид компиляции, который выполняется во время выполнения программы, а не до её 
запуска. 

JIT-компилятор берет участок кода, который много раз выполняется (например, функция или цикл), и компилирует его в 
низкоуровневый машинный код. Этот машинный код сохраняется и затем используется каждый раз, когда необходимо выполнить 
этот участок кода.

Использование JIT-компиляции позволяет увеличить производительность программы, так как компилируемый код выполняется 
намного быстрее, чем код, интерпретируемый виртуальной машиной Java или другими интерпретаторами. JIT-компиляция 
позволяет достичь компромисса между производительностью компиляции и гибкостью интерпретации кода.