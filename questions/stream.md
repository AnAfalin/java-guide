#### [Оглавление](../README.md)

# Stream
+ [Что такое _«лямбда»_? Какова структура и особенности использования лямбда-выражения?](#что-такое-лямбда--какова-структура-и-особенности-использования-лямбда-выражения)
+ [К каким переменным есть доступ у лямбда-выражений?](#к-каким-переменным-есть-доступ-у-лямбда-выражений)
+ [Как отсортировать список строк с помощью лямбда-выражения?](#как-отсортировать-список-строк-с-помощью-лямбда-выражения)
+ [Что такое «ссылка на метод»?](#что-такое-ссылка-на-метод)
+ [Какие виды ссылок на методы вы знаете?](#какие-виды-ссылок-на-методы-вы-знаете)
+ [Объясните выражение `System.out::println`](#объясните-выражение-systemoutprintln)
+ [Что такое `Stream`?](#что-такое-stream-)
+ [Какие существуют способы создания стрима?](#какие-существуют-способы-создания-стрима)
+ [В чем разница между `Collection` и `Stream`?](#в-чем-разница-между-collection-и-stream-)
+ [Для чего нужен метод `collect()` в стримах?](#для-чего-нужен-метод-collect-в-стримах)
+ [Для чего в стримах применяются методы `forEach()` и `forEachOrdered()`?](#для-чего-в-стримах-применяются-методы-foreach-и-foreachordered-)
+ [Для чего в стримах предназначены методы `map()` и `mapToInt()`, `mapToDouble()`, `mapToLong()`?](#для-чего-в-стримах-предназначены-методы-map-и-maptoint--maptodouble--maptolong-)
+ [Какова цель метода `filter()` в стримах?](#какова-цель-метода-filter---в-стримах)
+ [Для чего в стримах предназначен метод `limit()`?](#для-чего-в-стримах-предназначен-метод-limit---)
+ [Для чего в стримах предназначен метод `sorted()`?](#для-чего-в-стримах-предназначен-метод-sorted---)
+ [Для чего в стримах предназначены методы `flatMap()`, `flatMapToInt()`, `flatMapToDouble()`, `flatMapToLong()`?](#для-чего-в-стримах-предназначены-методы-map-и-maptoint--maptodouble--maptolong-)
+ [Расскажите о параллельной обработке в Java 8.](#Расскажите-о-параллельной-обработке-в-java-8)
+ [Какие конечные методы работы со стримами вы знаете?](#Какие-конечные-методы-работы-со-стримами-вы-знаете)
+ [Какие промежуточные методы работы со стримами вы знаете?](#Какие-промежуточные-методы-работы-со-стримами-вы-знаете)
+ [Как вывести на экран 10 случайных чисел, используя `forEach()`?](#как-вывести-на-экран-10-случайных-чисел-используя-foreach-)
+ [Как можно вывести на экран уникальные квадраты чисел используя метод `map()`?](#как-можно-вывести-на-экран-уникальные-квадраты-чисел-используя-метод-map-)
+ [Как вывести на экран количество пустых строк с помощью метода `filter()`?](#как-вывести-на-экран-количество-пустых-строк-с-помощью-метода-filter-)
+ [Как вывести на экран 10 случайных чисел в порядке возрастания?](#Как-вывести-на-экран-10-случайных-чисел-в-порядке-возрастания)
+ [Как найти максимальное число в наборе?](#как-найти-максимальное-число-в-наборе)
+ [Как найти минимальное число в наборе?](#как-найти-минимальное-число-в-наборе)
+ [Как получить сумму всех чисел в наборе?](#как-получить-сумму-всех-чисел-в-наборе)
+ [Как получить среднее значение всех чисел?](#как-получить-среднее-значение-всех-чисел)
+ [Какие дополнительные методы для работы с ассоциативными массивами (maps) появились в Java 8?](#какие-дополнительные-методы-для-работы-с-ассоциативными-массивами--maps--появились-в-java-8)
+ [Что такое `Optional`?](#что-такое-optional-)

_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Что такое _«лямбда»_? Какова структура и особенности использования лямбда-выражения?

__Лямбда__ представляет собой набор инструкций, которые можно выделить в отдельную переменную и затем многократно вызвать в различных местах программы.

Основу лямбда-выражения составляет _лямбда-оператор_, который представляет стрелку `->`. Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения, а правая, собственно, представляет тело лямбда-выражения, где выполняются все действия.

Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе. При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.

```java
interface Operationable {
    int calculate(int x, int y);
}

public static void main(String[] args) {
    Operationable operation = (x, y) -> x + y;     
    int result = operation.calculate(10, 20);
    System.out.println(result); //30
}
```

По факту лямбда-выражения являются в некотором роде сокращенной формой внутренних анонимных классов, которые ранее 
применялись в Java.

+ _Отложенное выполнение (deferred execution) лямбда-выражения_- определяется один раз в одном месте программы, 
+ вызываются при необходимости, любое количество раз и в произвольном месте программы.

+ _Параметры лямбда-выражения_ должны соответствовать по типу параметрам метода функционального интерфейса:

```java
operation = (int x, int y) -> x + y;
//При написании самого лямбда-выражения тип параметров разрешается не указывать:
(x, y) -> x + y;
//Если метод не принимает никаких параметров, то пишутся пустые скобки, например,
() -> 30 + 20;
//Если метод принимает только один параметр, то скобки можно опустить:
n -> n * n;
```

+ _Конечные лямбда-выражения_ не обязаны возвращать какое-либо значение.

```java
interface Printable {
    void print(String s);
}
 
public static void main(String[] args) {
    Printable printer = s -> System.out.println(s);
    printer.print("Hello, world");
}
```

+ _Блочные лямбда-выражения_ обрамляются фигурными скобками. В блочных лямбда-выражениях можно использовать внутренние вложенные блоки, циклы, конструкции `if`, `switch`, создавать переменные и т.д. Если блочное лямбда-выражение должно возвращать значение, то явным образом применяется оператор `return`:

```java
Operationable operation = (int x, int y) -> {       
    if (y == 0) {
        return 0;
    }
    else {
        return x / y;
    }
};
```

+ _Передача лямбда-выражения в качестве параметра метода_:

```java
interface Condition {
    boolean isAppropriate(int n);
}

private static int sum(int[] numbers, Condition condition) {
    int result = 0;
    for (int i : numbers) {
        if (condition.isAppropriate(i)) {
            result += i;
        }
    }
    return result;
}

public static void main(String[] args) {
    System.out.println(sum(new int[] {0, 1, 0, 3, 0, 5, 0, 7, 0, 9}, (n) -> n != 0));
} 
```
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## К каким переменным есть доступ у лямбда-выражений?

Доступ к переменным внешней области действия из лямбда-выражения очень схож к доступу из анонимных объектов. Можно
ссылаться на:
+ неизменяемые (_effectively final_ - не обязательно помеченные как `final`) локальные переменные;
+ поля класса;
+ статические переменные.

К методам по умолчанию реализуемого функционального интерфейса обращаться внутри лямбда-выражения запрещено.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Как отсортировать список строк с помощью лямбда-выражения?

```java
public static List<String> sort(List<String> list){
    Collections.sort(list, (a, b) -> a.compareTo(b));
    return list;
}
```
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Что такое «ссылка на метод»?

Если существующий в классе метод уже делает все, что необходимо, то можно воспользоваться механизмом __method reference 
(ссылка на метод)__ для непосредственной передачи этого метода. Такая ссылка передается в виде:
+ `имя_класса::имя_статического_метода` для статического метода;
+ `объект_класса::имя_метода` для метода экземпляра;
+ `название_класса::new` для конструктора.

Результат будет в точности таким же, как в случае определения лямбда-выражения, которое вызывает этот метод.

```java
private interface Measurable {
    public int length(String string);
}

public static void main(String[] args) {
    Measurable a = String::length;
    System.out.println(a.length("abc"));
}
```

Ссылки на методы потенциально более эффективны, чем использование лямбда-выражений. Кроме того, они предоставляют 
компилятору более качественную информацию о типе и при возможности выбора между использованием ссылки на существующий 
метод и использованием лямбда-выражения, следует всегда предпочитать использование ссылки на метод.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Какие виды ссылок на методы вы знаете?

+ на статический метод;
+ на метод экземпляра;
+ на конструкторе.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Объясните выражение `System.out::println`

Данное выражение иллюстрирует механизм _instance method reference_: передачи ссылки на метод `println()` статического 
поля `out` класса `System`.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Что такое `Stream`?

Интерфейс `java.util.Stream` представляет собой последовательность элементов, над которой можно производить различные 
операции.

Операции над стримами бывают или _промежуточными (intermediate)_ или _конечными (terminal)_. Конечные операции возвращают 
результат определенного типа, а промежуточные операции возвращают тот же стрим. Таким образом вы можете строить цепочки 
из несколько операций над одним и тем же стримом.

У стрима может быть сколько угодно вызовов промежуточных операций и последним вызов конечной операции. При этом все 
промежуточные операции выполняются лениво и пока не будет вызвана конечная операция никаких действий на самом деле не 
происходит (похоже на создание объекта `Thread` или `Runnable`, без вызова `start()`).

Стримы создаются на основе каких-либо источников, например классов из `java.util.Collection`.

Ассоциативные массивы (maps), например, `HashMap`, не поддерживаются.

Операции над стримами могут выполняться как последовательно, так и параллельно.

Потоки не могут быть использованы повторно. Как только была вызвана какая-нибудь конечная операция, поток закрывается.

Кроме универсальных объектных существуют особые виды стримов для работы с примитивными типами данных `int`, `long` и 
`double`: `IntStream`, `LongStream` и `DoubleStream`. Эти примитивные стримы работают так же, как и обычные объектные, 
но со следующими отличиями:

+ используют специализированные лямбда-выражения, например, `IntFunction` или `IntPredicate` вместо `Function` и 
`Predicate`;
+ поддерживают дополнительные конечные операции `sum()`, `average()`, `mapToObj()`.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Какие существуют способы создания стрима?

1. Из коллекции:
```java 
Stream<String> fromCollection = Arrays.asList("x", "y", "z").stream();
```
2. Из набора значений:
```java 
Stream<String> fromValues = Stream.of("x", "y", "z");
```
3. Из массива:
```java 
Stream<String> fromArray = Arrays.stream(new String[]{"x", "y", "z"});
```
4. Из файла (каждая строка в файле будет отдельным элементом в стриме):
```java 
Stream<String> fromFile = Files.lines(Paths.get("input.txt"));
```
5. Из строки:
```java 
IntStream fromString = "0123456789".chars();
```
6. С помощью `Stream.builder()`:
```java 
Stream<String> fromBuilder = Stream.builder().add("z").add("y").add("z").build();
```
7. С помощью `Stream.iterate()` (бесконечный):
```java 
Stream<Integer> fromIterate = Stream.iterate(1, n -> n + 1);
```
8. С помощью `Stream.generate()` (бесконечный):
```java 
Stream<String> fromGenerate = Stream.generate(() -> "0");
```
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## В чем разница между `Collection` и `Stream`?
Коллекции позволяют работать с элементами по-отдельности, тогда как стримы так делать не позволяют, но вместо этого 
предоставляют возможность выполнять функции над данными как над одним целым.

Также стоит отметить важность самой концепции сущностей: `Collection` - это прежде всего воплощение _Структуры Данных_. 
Например, `Set` не просто хранит в себе элементы, он реализует идею множества с уникальными элементами,
тогда как `Stream`, это прежде всего абстракция необходимая для реализации _конвейера вычислений_, собственно, поэтому, 
результатом работы конвейера являются те или иные _Структуры Данных_ или же результаты проверок/поиска и т.п.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Для чего нужен метод `collect()` в стримах?

Метод `collect()` является конечной операцией, которая используется для представления результата в виде коллекции или 
какой-либо другой структуры данных.

`collect()` принимает на вход `Collector<Тип_источника, Тип_аккумулятора, Тип_результата>`, который содержит четыре 
этапа: _supplier_ - инициализация аккумулятора, _accumulator_ - обработка каждого элемента, _combiner_ - соединение двух 
аккумуляторов при параллельном выполнении, _[finisher]_ - необязательный метод последней обработки аккумулятора. 
В Java 8 в классе `Collectors` реализовано несколько распространённых коллекторов:

+ `toList()`, `toCollection()`, `toSet()` - представляют стрим в виде списка, коллекции или множества;
+ `toConcurrentMap()`, `toMap()` - позволяют преобразовать стрим в `Map`;
+ `averagingInt()`, `averagingDouble()`, `averagingLong()` - возвращают среднее значение;
+ `summingInt()`, `summingDouble()`, `summingLong()` - возвращает сумму;
+ `summarizingInt()`, `summarizingDouble()`, `summarizingLong()` - возвращают `SummaryStatistics` с разными агрегатными 
значениями;
+ `partitioningBy()` - разделяет коллекцию на две части по соответствию условию и возвращает их как `Map<Boolean, List>`;
+ `groupingBy()` - разделяет коллекцию на несколько частей и возвращает `Map<N, List<T>>`;
+ `mapping()` - дополнительные преобразования значений для сложных `Collector`-ов.

Так же существует возможность создания собственного коллектора через `Collector.of()`:

```java
Collector<String, List<String>, List<String>> toList = Collector.of(
    ArrayList::new,
    List::add,
    (l1, l2) -> { l1.addAll(l2); return l1; }
);
```
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Для чего в стримах применяются методы `forEach()` и `forEachOrdered()`?

+ `forEach()` применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется;
+ `forEachOrdered()` применяет функцию к каждому объекту стрима с сохранением порядка элементов.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Для чего в стримах предназначены методы `map()` и `mapToInt()`, `mapToDouble()`, `mapToLong()`?

Метод `map()` является промежуточной операцией, которая заданным образом преобразует каждый элемент стрима.

`mapToInt()`, `mapToDouble()`, `mapToLong()` - аналоги `map()`, возвращающие соответствующий числовой стрим (то есть 
стрим из числовых примитивов):

```java
Stream
    .of("12", "22", "4", "444", "123")
    .mapToInt(Integer::parseInt)
    .toArray(); //[12, 22, 4, 444, 123]
```_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Какова цель метода `filter()` в стримах?
Метод `filter()` является промежуточной операцией принимающей предикат, который фильтрует все элементы, возвращая только те, что соответствуют условию.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Для чего в стримах предназначен метод `limit()`?
Метод `limit()` является промежуточной операцией, которая позволяет ограничить выборку определенным количеством первых элементов.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Для чего в стримах предназначен метод `sorted()`?
Метод `sorted()` является промежуточной операцией, которая позволяет сортировать значения либо в натуральном порядке, либо задавая `Comparator`.

Порядок элементов в исходной коллекции остается нетронутым - `sorted()` всего лишь создает его отсортированное представление.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Для чего в стримах предназначены методы `flatMap()`, `flatMapToInt()`, `flatMapToDouble()`, `flatMapToLong()`?
Метод `flatMap()` похож на map, но может создавать из одного элемента несколько. Таким образом, каждый объект будет преобразован в ноль, один или несколько других объектов, поддерживаемых потоком.  Наиболее очевидный способ применения этой операции — преобразование элементов контейнера при помощи функций, которые возвращают контейнеры.

```java
Stream
    .of("H e l l o", "w o r l d !")
    .flatMap((p) -> Arrays.stream(p.split(" ")))
    .toArray(String[]::new);//["H", "e", "l", "l", "o", "w", "o", "r", "l", "d", "!"]
```

`flatMapToInt()`, `flatMapToDouble()`, `flatMapToLong()` - это аналоги `flatMap()`, возвращающие соответствующий 
числовой стрим.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Какова цель метода filter() в стримах?

Метод filter() является промежуточной операцией, принимающей предикат, который фильтрует все элементы, возвращая только 
те, что соответствуют условию.

_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Для чего в стримах предназначен метод limit()?

Метод limit() является промежуточной операцией, которая позволяет ограничить выборку определенным количеством первых элементов.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Для чего в стримах предназначен метод sorted()?

Метод sorted() является промежуточной операцией, которая позволяет сортировать значения либо
в натуральном порядке, либо задавая Comparator.
Порядок элементов в исходной коллекции остается нетронутым - sorted() всего лишь создает его
отсортированное представление
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Расскажите о параллельной обработке в Java 8

Стримы могут быть последовательными и параллельными. Операции над последовательными стримами выполняются в одном потоке 
процессора, над параллельными — используя несколько потоков процессора. Параллельные стримы используют общий 
`ForkJoinPool` доступный через статический `ForkJoinPool.commonPool()` метод. При этом, если окружение не является 
многоядерным, то поток будет выполняться как последовательный. Фактически применение параллельных стримов сводится к 
тому, что данные в стримах будут разделены на части, каждая часть обрабатывается на отдельном ядре процессора, и в 
конце эти части соединяются, и над ними выполняются конечные операции.

Для создания параллельного потока из коллекции можно также использовать метод `parallelStream()` интерфейса `Collection`.

Чтобы сделать обычный последовательный стрим параллельным, надо вызвать у объекта `Stream` метод `parallel()`. Метод 
`isParallel()` позволяет узнать является ли стрим параллельным.

С помощью, методов `parallel()` и `sequential()` можно определять какие операции могут быть параллельными, а какие 
только последовательными. Так же из любого последовательного стрима можно сделать параллельный и наоборот:

```java
collection
.stream()
.peek(...) // операция последовательна
.parallel()
.map(...) // операция может выполняться параллельно,
.sequential()
.reduce(...) // операция снова последовательна 
```

Как правило, элементы передаются в стрим в том же порядке, в котором они определены в источнике данных. При работе 
с параллельными стримами система сохраняет порядок следования элементов. Исключение составляет метод `forEach()`, 
который может выводить элементы в произвольном порядке. И чтобы сохранить порядок следования, необходимо применять 
метод `forEachOrdered()`.

Критерии, которые могут повлиять на производительность в параллельных стримах:

+ Размер данных - чем больше данных, тем сложнее сначала разделять данные, а потом их соединять.
+ Количество ядер процессора. Теоретически, чем больше ядер в компьютере, тем быстрее программа будет работать. 
Если на машине одно ядро, нет смысла применять параллельные потоки.
+ Чем проще структура данных, с которой работает поток, тем быстрее будут происходить операции. Например, данные из
+ `ArrayList` легко использовать, так как структура данной коллекции предполагает последовательность несвязанных данных. 
А вот коллекция типа `LinkedList` - не лучший вариант, так как в последовательном списке все элементы связаны с 
предыдущими/последующими. И такие данные трудно распараллелить.
+ Над данными примитивных типов операции будут производиться быстрее, чем над объектами классов.
+ Крайне не рекомендуется использовать параллельные стримы для скольких-нибудь долгих операций (например, сетевых 
соединений), так как все параллельные стримы работают c одним ForkJoinPool, то такие долгие операции могут остановить 
работу всех параллельных стримов в JVM из-за отсутствия доступных потоков в пуле, т.е. параллельные стримы стоит 
использовать лишь для коротких операций, где счет идет на миллисекунды, но не для тех где счет может идти на секунды и 
минуты;
+ Сохранение порядка в параллельных стримах увеличивает издержки при выполнении и если порядок не важен, то имеется 
возможность отключить его сохранение и тем самым увеличить производительность, использовав промежуточную операцию 
`unordered()`:

```java
collection.parallelStream()
    .sorted()
    .unordered()
    .collect(Collectors.toList());
```
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Какие конечные методы работы со стримами вы знаете?

+ `findFirst()` возвращает первый элемент;
+ `findAny()` возвращает любой подходящий элемент;
+ `collect()` представление результатов в виде коллекций и других структур данных;
+ `count()` возвращает количество элементов;
+ `anyMatch()` возвращает `true`, если условие выполняется хотя бы для одного элемента;
+ `noneMatch()` возвращает `true`, если условие не выполняется ни для одного элемента;
+ `allMatch()` возвращает `true`, если условие выполняется для всех элементов;
+ `min()` возвращает минимальный элемент, используя в качестве условия `Comparator`;
+ `max()` возвращает максимальный элемент, используя в качестве условия `Comparator`;
+ `forEach()` применяет функцию к каждому объекту (порядок при параллельном выполнении не гарантируется);
+ `forEachOrdered()` применяет функцию к каждому объекту с сохранением порядка элементов;
+ `toArray()` возвращает массив значений;
+ `reduce()`позволяет выполнять агрегатные функции и возвращать один результат.

Для числовых стримов дополнительно доступны:

+ `sum()` возвращает сумму всех чисел;
+ `average()` возвращает среднее арифметическое всех чисел.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Какие промежуточные методы работы со стримами вы знаете?

+ `filter()` отфильтровывает записи, возвращая только записи, соответствующие условию;
+ `skip()` позволяет пропустить определённое количество элементов в начале;
+ `distinct()` возвращает стрим без дубликатов (для метода `equals()`);
+ `map()` преобразует каждый элемент;
+ `peek()` возвращает тот же стрим, применяя к каждому элементу функцию;
+ `limit()` позволяет ограничить выборку определенным количеством первых элементов;
+ `sorted()` позволяет сортировать значения либо в натуральном порядке, либо задавая `Comparator`;
+ `mapToInt()`, `mapToDouble()`, `mapToLong()` - аналоги `map()` возвращающие стрим числовых примитивов;
+ `flatMap()`, `flatMapToInt()`, `flatMapToDouble()`, `flatMapToLong()` - похожи на `map()`, но могут создавать из одного элемента несколько.

Для числовых стримов дополнительно доступен метод `mapToObj()`, который преобразует числовой стрим обратно в объектный.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Как вывести на экран 10 случайных чисел, используя `forEach()`?

```java
(new Random())
    .ints()
    .limit(10)
    .forEach(System.out::println);
```
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Как можно вывести на экран уникальные квадраты чисел используя метод `map()`?

```java
Stream
    .of(1, 2, 3, 2, 1)
    .map(s -> s * s)
    .distinct()
    .forEach(System.out::println);
```
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Как вывести на экран количество пустых строк с помощью метода `filter()`?
```java
System.out.println(
    Stream
        .of("Hello", "", ", ", "world", "!")
        .filter(String::isEmpty)
        .count());
```
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Как вывести на экран 10 случайных чисел в порядке возрастания?

```java
(new Random())
    .ints()
    .limit(10)
    .sorted()
    .forEach(System.out::println);
```
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Как найти максимальное число в наборе?

```java
Stream
    .of(5, 3, 4, 55, 2)
    .mapToInt(a -> a)
    .max()
    .getAsInt(); //55
```
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Как найти минимальное число в наборе?

```java
Stream
    .of(5, 3, 4, 55, 2)
    .mapToInt(a -> a)
    .min()
    .getAsInt(); //2
```_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Как получить сумму всех чисел в наборе?
```java
Stream
    .of(5, 3, 4, 55, 2)
    .mapToInt()
    .sum(); //69
```_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Как получить среднее значение всех чисел?
```java
Stream
    .of(5, 3, 4, 55, 2)
    .mapToInt(a -> a)
    .average()
    .getAsDouble(); //13.8
```
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Как получить сумму всех чисел в наборе?
```
Stream
.of(5, 3, 4, 55, 2)
.mapToInt()
.sum(); //69
```
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Как получить среднее значение всех чисел?

```
Stream
.of(5, 3, 4, 55, 2)
.mapToInt(a -> a)
.average()
.getAsDouble(); //13.8
```
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Какие дополнительные методы для работы с ассоциативными массивами (maps) появились в Java 8?

+ `putIfAbsent()` добавляет пару «ключ-значение», только если ключ отсутствовал:

`map.putIfAbsent("a", "Aa");`

+ `forEach()` принимает функцию, которая производит операцию над каждым элементом:

`map.forEach((k, v) -> System.out.println(v));`

+ `compute()` создаёт или обновляет текущее значение на полученное в результате вычисления (возможно использовать ключ и текущее значение):

`map.compute("a", (k, v) -> String.valueOf(k).concat(v)); //["a", "aAa"]`

+ `computeIfPresent()` если ключ существует, обновляет текущее значение на полученное в результате вычисления (возможно использовать ключ и текущее значение):

`map.computeIfPresent("a", (k, v) -> k.concat(v));`

+ `computeIfAbsent()` если ключ отсутствует, создаёт его со значением, которое вычисляется (возможно использовать ключ):

`map.computeIfAbsent("a", k -> "A".concat(k)); //["a","Aa"]`

+ `getOrDefault()` в случае отсутствия ключа, возвращает переданное значение по-умолчанию:

`map.getOrDefault("a", "not found");`

+ `merge()` принимает ключ, значение и функцию, которая объединяет передаваемое и текущее значения. Если под заданным ключем значение отсутствует, то записывает туда передаваемое значение.

`map.merge("a", "z", (value, newValue) -> value.concat(newValue)); //["a","Aaz"]`
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#stream)</span>

## Что такое `Optional`?

__Опциональное значение `Optional`___ — это контейнер для объекта, который может содержать или не содержать 
значение `null`. 

Такая обёртка является удобным средством предотвращения `NullPointerException`, т.к. имеет некоторые функции высшего 
порядка, избавляющие от добавления повторяющихся `if null/notNull` проверок:

```java
Optional<String> optional = Optional.of("hello");

optional.isPresent(); // true
optional.ifPresent(s -> System.out.println(s.length())); // 5
optional.get(); // "hello"
optional.orElse("ops..."); // "hello"
```