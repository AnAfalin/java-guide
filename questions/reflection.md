#### [Оглавление](../README.md)

# Рефлексия и Аннотации
+ [Аннотации](#аннотации)
+ [Встроенные аннотации](#встроенные-аннотации)
+ [Создание своих аннотаций](#создание-своих-аннотаций)
+ [Рефлексия](#рефлексия)
+ [Как определить повторяемую аннотацию?](#как-определить-повторяемую-аннотацию)
+ 
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#рефлексия-и-аннотации)</span>

## Аннотации

__Аннотация__ — это специальная конструкция языка, связанная с классом, методом или переменной, предоставляющая программе 
дополнительную информацию, на основе которой программа может предпринять дальнейшие действия или реализовать 
дополнительную функциональность, такую как генерация кода, проверка ошибок и т. д.

__Аннотация__ является своего рода меткой в коде, описывающая метаданные для метода/класса/пакета, которые в свою очередь 
могут передавать какую-либо информацию для Java компилятора. Аннотации используются рефлексией.

__Метаданные (данные о данных)__ - данные, относящиеся к дополнительной информации о содержимом или объекте.

Для всех аннотаций суперинтерфейсом является класс `Annotation`.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#рефлексия-и-аннотации)</span>

## Встроенные аннотации
`@Ovveride` - используется для пометки метода как переопределяющий другой метод из родительского класса.

Сама по себе аннотация не выполняет никаких действий. Она просто предоставляет информацию, которую можно использовать 
во время компиляции или в рантайме.
При компиляции в примере ниже программа выдаст ошибку, потому что метод `getname()` в классе `ChildClass` аннотирован 
`@Override`, но в родительском классе ParentClass метода getname() нет.

Используя аннотацию @Override в `ChildClass`, компилятор проверяет, что имя переопределенного метода в дочернем классе 
совпадает с именем метода в родительском классе.

```java
public class ParentClass {
  public String getName() {...}
}

public class ChildClass extends ParentClass {
  @Override
  public String getname() {...}
}
```

`@SuppressWarnings` - используется для указания компилятору подавлять предупреждения для метода, над которым используется
аннотация. Например, если метод вызывает устаревший метод или выполняет небезопасное приведение типа, то компилятор
может сгенерировать предупреждение, а данная аннотация подавляет данные предупреждения.

`@Deprecated` - помечает класс или метод как устаревший.

IDE автоматически обрабатывают эту аннотацию и обычно отображают устаревший метод зачеркнутым шрифтом, сообщая 
разработчику, что больше не следует его использовать.

`@SafeVarargs` - сообщает конструктору или методы (`static` или `final`), что применение аргументов переменной длины 
является безопасным.

Используется только с `static` или `final` методы, т.к. такие методы не наследуются и поэтому не могут быть переопределены.
Ведь если бы переопределенип допускалось, то переопределенный метод мог ослабить ограничения и метод больше не был бы
"безопасным".

`@FunctionalInterface` используется для указания того, что в интерфейсе не может быть более одного абстрактного 
метода. Если абстрактных методов будет больше одного, то компилятор выдаст ошибку. Функциональные интерфейсы появились 
в Java 8 для реализации лямбда-выражений и гарантии того, что в них не более одного абстрактного метода.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#рефлексия-и-аннотации)</span>

## Создание своих аннотаций

Создание своих аннотаий позволяет реализацовать следующюю функциональность:
+ Уменьшение дублирования кода.
+ Автоматизация генерации бойлерплейт кода.
+ Отлов ошибок во время компиляции, например, потенциальные Null Pointer Exception.
+ Настройка поведения в рантайме на основе наличия аннотации.

Для создания пользовательской аннотации используется ключевое слово `@interface`:
```java
public @interface Company{
}
```

__Мета-аннотации__ — это аннотации, применяемые к другим аннотациям для предоставления информации об аннотации 
компилятору или среде выполнения.

Мета-аннотации могут ответить на следующие вопросы об аннотации:
+ Может ли аннотация наследоваться дочерними классами?
+ Должна ли аннотация отображаться в документации?
+ Можно ли применить аннотацию несколько раз к одному и тому же элементу?
+ К какому типу элементов можно применить аннотацию: к классу, методу, полю и т.д.?
+ Обрабатывается ли аннотация во время компиляции или в рантайме?

`@Inherited` позволяет унаследовать аннотации суперкласса (подклассы будут иметь те же аннотации, что и суперклассс). 

По умолчанию аннотация не наследуется от родительского класса к дочернему. Мета-аннотация @Inherited позволяет это исправить.

`@Target` — указывает, к какому элементу будет применяться аннотация (метод, класс, поле и т.д.).
+ `ElementType.ANNOTATION_TYPE`
+ `ElementType.CONSTRUCTOR`
+ `ElementType.FIELD`
+ `ElementType.LOCAL_VARIABLE`
+ `ElementType.METHOD`
+ `ElementType.PACKAGE`
+ `ElementType.PARAMETER`
+ `ElementType.TYPE`

`@Retention` — указывает, когда аннотация будет доступна:
+ `RentetionPolicy.SOURCE` — аннотация доступна в исходном коде и удаляется после компиляции.
+ `RentetionPolicy.CLASS` — аннотация сохраняется в class-файле во время компиляции, но недоступна при выполнении программы.
+ `RentetionPolicy.RUNTIME` — аннотация доступна в рантайме, во время выполнения и в байт-коде (.class).

Если аннотация нужна только для проверки ошибок во время компиляции, как это делает @Override, мы используем SOURCE. 

Если аннотация нужна для обеспечения функциональности в рантайме, например, @Test в JUnit, то используем RUNTIME.

`@Documented` — указывает, что аннотация должна присутствовать в JavaDoc.  

По умолчанию информация об аннотациях не отображается в JavaDoc-документации, но если использовать @Documented, она появится.

`@Repeatable` позволяет использовать аннотацию несколько раз на одном методе, классе или поле. Для использования 
`@Repeatable` — аннотации необходимо создать аннотацию-контейнер, которая хранит значение в виде массива исходных аннотаций:

```java
@Target(ElementType.TYPE)
@Repeatable(RepeatableCompanies.class)
@Retention(RetentionPolicy.RUNTIME)
public @interface RepeatableCompany {
  String name() default "Name_1";
  String city() default "City_1";
}
```

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface RepeatableCompanies {
  RepeatableCompany[] value() default{};
}
```

Использовать аннотацию можно следующим образом:
```java
@RepeatableCompany
@RepeatableCompany(name =  "Name_2", city = "City_2")
public class RepeatedAnnotatedEmployee {
}
```

Аннотации также могут иметь поля, но только следующих типов:
+ примитивные типы
+ String или Class
+ enum
+ annotation
+ массив элементов любого из вышеперечисленных типов

Каждое поле должно быть проиницилизировано при использовании аннотации, иначе будет ошибка.
Но также можно задать и значение по умолчанию используя ключевое слово `default`.
```java
public @interface MyAnnotation {
    String author() default "Author";
    int year() default 2024;
}
```

Аннотации с одним значением содержат только один атрибут, который принято называть value.

В качестве параметров аннотации можно использовать константы. Вычисляемые во время выполнения программы значения использоваться
не могут. Например, `Math.sqrt(10)`.
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#рефлексия-и-аннотации)</span>

## Рефлексия

__Рефлексия__ - средство для получения сведений о классе во время выполнения программы. Для того чтобы поспользоваться
рефлексией, нужно получить объект типа `Class`.

Использование рефлексии позволяет:
+ Узнать/определить класс объекта
+ Получить информацию о полях, методах, константах, конструкторах и суперклассах
+ Выяснить какие методы имеет класс, вызвать эти методы
+ Создать экземпляр класса, причем именя класса неизвестно до момента выполнения программы
+ Получить и установить значение поля объекта по имени

+ Получение Class
```java
// через название класса
Class<Example> cl = Example.class;

// через объект
Example ex = new Example();
Class<Example> cl = ex.getClass();

// по полному имени класса
Class<?> cl = Class.forName("com.example.Example");
```

+ Получение имени класса:
```java
Class<?> myClassClass = MyClass.class;
String className = myClassClass.getName(); // Возвращает "com.example.MyClass"
```

+ Получение имени пакета:
```java
Package classPackage = myClassClass.getPackage();
String packageName = classPackage.getName(); // Возвращает "com.example"
```

+ Получение суперкласса:
```java
Class<?> superClass = myClassClass.getSuperclass();
```

+ Получение интерфейсов:
```java
Class<?>[] interfaces = myClassClass.getInterfaces();
```

+ Получение методов
```java
Class<?> myClassClass = MyClass.class;
// получение всех методов класса, включая методы из суперклассов (интерфейсов).
Method method = myClassClass.getMethods();
// получение только написанных нами методов класса
Method method = myClassClass.getDelcaredMethos();
```

+ Вызов метода
```java
Class<?> myClassClass = MyClass.class;
Method method = myClassClass.getMethod("someMethod", int.class);
MyClass instance = new MyClass(); // объект, на котором вызываем метод
int result = (int) method.invoke(instance, 42);
```

Для того чтобы можно было вызвать и приватный метод, то нужно обязательно открыть доступ к нему:
```java
method.setAccessible(true);
```

+ Получение полей - `getDeclaredFields()`;
+ Открытые доступа к полю - `field.setAccessible(true)`; 
+ Изменение значения поля - `field(ex, 333)`; (ex - объект на котором вызываем изменение значения поля)

+ Чтение поля
```java
Class<?> myClassClass = MyClass.class;
Field field = myClassClass.getField("fieldName");
MyClass instance = new MyClass();
String value = (String) field.get(instance);
```

+ Создание объекта через рефлексию
  - без аргументов
```java
Constructor<Example> noArgsConstr = cl.getDeclaredConstructor();
Example ex = noArgsConstr.newInstance();
```
  - с аргументами
```java
```java
Constructor<Example> argsConstr = cl.getDeclaredConstructor(int.class, String.class);
Example ex = argsConstr.newInstance(10, "Tom");
```

+ Получение аннотаций - `getDeclaredAnnotations();` 
+ Получение аннотации по классу - `getAnnotation(MyAnnot.class);
_______________________________________________________________________________________________________________________
<span style="display: inline-block; float: right">[содержание](#рефлексия-и-аннотации)</span>

## Как определить повторяемую аннотацию?
Чтобы определить повторяемую аннотацию, необходимо создать аннотацию-контейнер для
списка повторяемых аннотаций и обозначить повторяемую мета-аннотацией @Repeatable:
```java
@interface Schedulers {
    Scheduler[] value();
}

@Repeatable(Schedulers.class)
@interface Scheduler {
    String birthday() default "Jan 8 1935";
}
```